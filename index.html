<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>News App</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <nav>
        <div class="main-nav container flex">
            <a href="#" onclick="reload()" class="company-logo">
                <img src="./assets/logo.png" alt="company logo">
            </a>
            <div class="nav-links">
                <ul class="flex">
                    <li class="hover-link nav-item" id="ipl" onclick="onNavItemClick('ipl')">IPL</li>
                    <li class="hover-link nav-item" id="finance" onclick="onNavItemClick('finance')">Finance</li>
                    <li class="hover-link nav-item" id="politics" onclick="onNavItemClick('politics')">Politics</li>
                </ul>
            </div>
            <div class="search-bar flex">
                <input id="search-text" type="text" class="news-input" placeholder="e.g. Science">
                <button id="search-button" class="search-button">Search</button>
            </div>
        </div>
    </nav>
    

    <main>
        <div class="cards-container container flex" id="cards-container">
            
        </div>
    </main>

    <div>
        <p>
            <br>
            <br>
            <br>
            <br>
        </p>
    </div>
    
    <div>
        
        <h1>hammingcode</h1>
        <pre>
            Q1. Write a shell script program for different string handling functions.
            #!/bin/bash
            
            echo "String Handling Functions in Shell Script"
            read -p "Enter a string: " str1
            read -p "Enter another string: " str2
            
            # Concatenate strings
            concatenated="$str1$str2"
            echo "Concatenated String: $concatenated"
            
            # Find the length of the string
            len1=${#str1}
            len2=${#str2}
            echo "Length of '$str1': $len1"
            echo "Length of '$str2': $len2"
            
            # Compare strings
            if [ "$str1" == "$str2" ]; then
              echo "Strings are equal."
            else
              echo "Strings are not equal."
            fi
            
            # Substring extraction
            start=2
            length=3
            substring=${str1:$start:$length}
            echo "Substring of '$str1' starting at index $start with length $length: $substring"
            
            # Check if string contains another string
            if [[ "$str1" == *"$str2"* ]]; then
              echo "'$str1' contains '$str2'."
            else
              echo "'$str1' does not contain '$str2'."
            fi
            
            Q2 Write a shell script program for different arithmetic functions, example-grading systems.
            #!/bin/bash
            
            echo "Welcome to the Arithmetic Functions and Grading System!"
            
            # Accept marks for subjects
            read -p "Enter marks for Mathematics: " math
            read -p "Enter marks for Science: " science
            read -p "Enter marks for English: " english
            
            # Arithmetic operations: Calculate total and percentage
            total=$((math + science + english))
            percentage=$(echo "scale=2; $total / 3" | bc)
            
            echo "Total Marks: $total"
            echo "Percentage: $percentage%"
            
            # Determine the grade based on percentage
            if (( $(echo "$percentage >= 90" | bc -l) )); then
              grade="A+"
            elif (( $(echo "$percentage >= 80" | bc -l) )); then
              grade="A"
            elif (( $(echo "$percentage >= 70" | bc -l) )); then
              grade="B+"
            elif (( $(echo "$percentage >= 60" | bc -l) )); then
              grade="B"
            elif (( $(echo "$percentage >= 50" | bc -l) )); then
              grade="C"
            else
              grade="F"
            fi
            
            echo "Your Grade: $grade"
            
            # Extra: Check if the student passed or failed
            if [ "$grade" == "F" ]; then
              echo "Result: Failed"
            else
              echo "Result: Passed"
            fi
            
            
            Q3. Write a shell script program for a number to check whether it is 
            1. palindrome 
            #!/bin/bash
            
            # Function to reverse a number
            reverse_number() {
              local num=$1
              local rev=0
              while [ $num -gt 0 ]; do
                local digit=$((num % 10))
                rev=$((rev * 10 + digit))
                num=$((num / 10))
              done
              echo $rev
            }
            
            # Read a number from the user
            echo -n "Enter a number: "
            read number
            
            # Reverse the number
            reversed=$(reverse_number $number)
            
            # Check if the number is a palindrome
            if [ "$number" -eq "$reversed" ]; then
              echo "$number is a palindrome."
            else
              echo "$number is not a palindrome."
            fi
             
            2.prime
            #!/bin/bash
            
            # Function to check if a number is prime
            is_prime() {
              local num=$1
            
              # Numbers less than 2 are not prime
              if [ $num -lt 2 ]; then
                echo "$num is not a prime number."
                return
              fi
            
              # Check divisors from 2 to the square root of the number
              for ((i = 2; i * i <= num; i++)); do
                if [ $((num % i)) -eq 0 ]; then
                  echo "$num is not a prime number."
                  return
                fi
              done
            
              # If no divisors found, it is prime
              echo "$num is a prime number."
            }
            
            # Read a number from the user
            echo -n "Enter a number: "
            read number
            
            # Call the function to check if the number is prime
            is_prime $number
            
            3.generate fibonacci 
            #!/bin/bash
            
            # Function to generate Fibonacci series
            generate_fibonacci() {
                num=$1
                a=0  # First term
                b=1  # Second term
            
                echo "Fibonacci series up to $num terms:"
            
                # Loop to generate Fibonacci terms
                for (( i=0; i<num; i++ )); do
                    echo -n "$a "  # Print the current term
                    fib=$((a + b)) # Calculate the next term
                    a=$b           # Update a to the previous b
                    b=$fib         # Update b to the calculated fib
                done
                echo # Newline for better formatting
            }
            
            # Input number of terms
            read -p "Enter the number of terms: " n
            
            # Check if input is valid
            if [[ $n -le 0 ]]; then
                echo "Please enter a positive integer."
            else
                generate_fibonacci $n
            fi
            
            4.Amstrong Number : 
            #!/bin/bash
            
            # Input from the user
            read -p "Enter a number: " num
            
            sum=0
            temp=$num
            length=${#num}  # Number of digits in the number
            
            # Loop to calculate the sum of digits raised to the power of the number of digits
            while [ $temp -gt 0 ]; do
                digit=$((temp % 10))              # Extract the last digit
                sum=$((sum + digit ** length))    # Add the digit raised to the power of the length
                temp=$((temp / 10))               # Remove the last digit
            done
            
            # Check if the calculated sum is equal to the original number
            if [ $sum -eq $num ]; then
                echo "$num is an Armstrong number."
            else
                echo "$num is not an Armstrong number."
            fi
            
            Q.4-6 Synchronization Problems:
            1)Producer Consumer Problem
            #include <stdio.h>
            #include <pthread.h>
            #include <semaphore.h>
            #include <stdlib.h>
            #include <unistd.h>
            #include <time.h>
            
            #define BUFFER_SIZE 5
            
            int buffer[BUFFER_SIZE];
            int in = 0, out = 0;
            sem_t empty, full;
            pthread_mutex_t mutex;
            
            void* producer(void* arg) {
                while (1) {
                    int item = rand() % 100;
                    sem_wait(&empty);
                    pthread_mutex_lock(&mutex);
            
                    buffer[in] = item;
                    printf("Produced: %d\n", item);
                    in = (in + 1) % BUFFER_SIZE;
            
                    pthread_mutex_unlock(&mutex);
                    sem_post(&full);
                    sleep(1);
                }
            }
            
            void* consumer(void* arg) {
                while (1) {
                    sem_wait(&full);
                    pthread_mutex_lock(&mutex);
            
                    int item = buffer[out];
                    printf("Consumed: %d\n", item);
                    out = (out + 1) % BUFFER_SIZE;
            
                    pthread_mutex_unlock(&mutex);
                    sem_post(&empty);
                    sleep(1);
                }
            }
            
            int main() {
                pthread_t prod, cons;
                sem_init(&empty, 0, BUFFER_SIZE);
                sem_init(&full, 0, 0);
                pthread_mutex_init(&mutex, NULL);
            
                srand(time(NULL));
                pthread_create(&prod, NULL, producer, NULL);
                pthread_create(&cons, NULL, consumer, NULL);
            
                pthread_join(prod, NULL);
                pthread_join(cons, NULL);
            
                sem_destroy(&empty);
                sem_destroy(&full);
                pthread_mutex_destroy(&mutex);
            
                return 0;
            }
            
            
            
            2)Reader Writer Problem
            #include <stdio.h>
            #include <stdlib.h>
            #include <pthread.h>
            #include <semaphore.h>
            #include <unistd.h>
            
            sem_t rw_mutex;        // Semaphore for writer access control
            sem_t mutex;           // Semaphore to control access to the reader count
            int read_count = 0;    // Number of readers currently accessing the resource
            int data = 0;          // Shared data resource (e.g., database value)
            
            void* reader(void* arg) {
                int id = *(int*)arg;
                while (1) {
                    sem_wait(&mutex); // Request access to modify read_count
                    read_count++;
                    if (read_count == 1) { // If this is the first reader
                        sem_wait(&rw_mutex); // Lock the writer semaphore
                    }
                    sem_post(&mutex); // Allow other readers to increment read_count
            
                    // Reading section (critical section for readers)
                    printf("Reader %d reads data = %d\n", id, data);
                    sleep(1); // Simulate read time
            
                    sem_wait(&mutex);
                    read_count--;
                    if (read_count == 0) { // If this is the last reader
                        sem_post(&rw_mutex); // Allow writers to access the resource
                    }
                    sem_post(&mutex);
            
                    sleep(1); // Simulate delay between reads
                }
            }
            
            void* writer(void* arg) {
                int id = *(int*)arg;
                while (1) {
                    sem_wait(&rw_mutex); // Request exclusive access for writing
            
                    // Writing section (critical section for writers)
                    data++; // Update the shared data
                    printf("Writer %d writes data = %d\n", id, data);
                    sleep(1); // Simulate write time
            
                    sem_post(&rw_mutex); // Release exclusive access
            
                    sleep(1); // Simulate delay between writes
                }
            }
            
            int main() {
                pthread_t readers[5], writers[2];
                int reader_ids[5] = {1, 2, 3, 4, 5};
                int writer_ids[2] = {1, 2};
            
                sem_init(&rw_mutex, 0, 1); // Initialize writer semaphore to 1 (only one writer at a time)
                sem_init(&mutex, 0, 1);    // Initialize reader count access semaphore to 1
            
                // Create reader threads
                for (int i = 0; i < 5; i++) {
                    pthread_create(&readers[i], NULL, reader, &reader_ids[i]);
                }
            
                // Create writer threads
                for (int i = 0; i < 2; i++) {
                    pthread_create(&writers[i], NULL, writer, &writer_ids[i]);
                }
            
                // Join threads (although in this infinite loop example, they will never terminate)
                for (int i = 0; i < 5; i++) {
                    pthread_join(readers[i], NULL);
                }
                for (int i = 0; i < 2; i++) {
                    pthread_join(writers[i], NULL);
                }
            
                // Destroy semaphores
                sem_destroy(&rw_mutex);
                sem_destroy(&mutex);
            
                return 0;
            }
            
            
            
            
            3)Dining Philosopher problem
            
            #include <stdio.h>
            #include <pthread.h>
            #include <unistd.h>
            #include <semaphore.h>
            
            #define N 5 // Number of philosophers
            #define THINKING 0
            #define HUNGRY 1
            
            // States of philosophers
            int state[N];
            
            // Mutex for critical sections
            pthread_mutex_t mutex;
            
            // Function declarations
            void *philosopher(void *num);
            void pick_up_forks(int phil_id);
            void put_down_forks(int phil_id);
            
            // Philosopher IDs
            int phil_ids[N] = {0, 1, 2, 3, 4};
            
            int main() {
                pthread_t philosophers[N];
            
                // Initialize mutex
                pthread_mutex_init(&mutex, NULL);
            
                // Create philosopher threads
                for (int i = 0; i < N; i++) {
                    pthread_create(&philosophers[i], NULL, philosopher, &phil_ids[i]);
                }
            
                // Join philosopher threads
                for (int i = 0; i < N; i++) {
                    pthread_join(philosophers[i], NULL);
                }
            
                pthread_mutex_destroy(&mutex);
                return 0;
            }
            
            void *philosopher(void *num) {
                int phil_id = *(int *)num;
            
                while (1) {
                    // Philosopher is thinking
                    printf("Philosopher %d is THINKING\n", phil_id);
                    sleep(1);
            
                    // Philosopher becomes hungry
                    pick_up_forks(phil_id);
            
                    // Simulate being hungry
                    sleep(1);
            
                    // Philosopher stops being hungry
                    put_down_forks(phil_id);
                }
            }
            
            void pick_up_forks(int phil_id) {
                pthread_mutex_lock(&mutex);
                state[phil_id] = HUNGRY;
                printf("Philosopher %d is HUNGRY\n", phil_id);
                pthread_mutex_unlock(&mutex);
            }
            
            void put_down_forks(int phil_id) {
                pthread_mutex_lock(&mutex);
                state[phil_id] = THINKING;
                printf("Philosopher %d is no longer HUNGRY and is now THINKING\n", phil_id);
                pthread_mutex_unlock(&mutex);
            }
            
            
            
            
            Q.6 -12Write a program to implement following CPU scheduling algorithms: 1) FCFS 2) Round Robin – time slice=4ms
            1.FCFS: 
            #include <stdio.h>
            
            struct Process {
                int id;
                int arrivalTime;
                int burstTime;
                int waitingTime;
                int turnaroundTime;
                int completionTime;
            };
            
            int main() {
                int n;
                printf("Enter the number of processes: ");
                scanf("%d", &n);
            
                struct Process processes[n];
            
                for (int i = 0; i < n; i++) {
                    processes[i].id = i + 1;
                    printf("Enter arrival time and burst time for Process P%d: ", processes[i].id);
                    scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
                }
            
                for (int i = 0; i < n - 1; i++) {
                    for (int j = i + 1; j < n; j++) {
                        if (processes[i].arrivalTime > processes[j].arrivalTime) {
                            struct Process temp = processes[i];
                            processes[i] = processes[j];
                            processes[j] = temp;
                        }
                    }
                }
            
                int currentTime = 0;
                float totalTurnaroundTime = 0, totalWaitingTime = 0;
            
                printf("\nProcess\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\n");
            
                for (int i = 0; i < n; i++) {
                    if (currentTime < processes[i].arrivalTime) {
                        currentTime = processes[i].arrivalTime; 
                    }
            
                    processes[i].completionTime = currentTime + processes[i].burstTime;
                    processes[i].turnaroundTime = processes[i].completionTime - processes[i].arrivalTime;
                    processes[i].waitingTime = processes[i].turnaroundTime - processes[i].burstTime;
            
                    currentTime = processes[i].completionTime;
            
                    totalTurnaroundTime += processes[i].turnaroundTime;
                    totalWaitingTime += processes[i].waitingTime;
            
                    printf("P%d\t%d\t%d\t%d\t\t%d\t\t%d\n",
                           processes[i].id, processes[i].arrivalTime, processes[i].burstTime,
                           processes[i].completionTime, processes[i].turnaroundTime, processes[i].waitingTime);
                }
            
                printf("\nAverage Turnaround Time: %.2f\n", totalTurnaroundTime / n);
                printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
            
                printf("\nGantt Chart:\n|");
                for (int i = 0; i < n; i++) {
                    printf(" P%d |", processes[i].id);
                }
                printf("\n0");
                for (int i = 0; i < n; i++) {
                    printf("   %d", processes[i].completionTime);
                }
                printf("\n");
            
                return 0;
            }
            
            2.Round-Robin TQ=4
            #include <stdio.h>
            
            struct Process {
                int id;
                int arrivalTime;
                int burstTime;
                int remainingTime;
                int completionTime;
                int turnaroundTime;
                int waitingTime;
            };
            
            void calculateTimes(struct Process processes[], int n, int timeQuantum) {
                int time = 0;
                int completed = 0;
            
                while (completed < n) {
                    for (int i = 0; i < n; i++) {
                        if (processes[i].remainingTime > 0 && processes[i].arrivalTime <= time) {
                            if (processes[i].remainingTime > timeQuantum) {
                                time += timeQuantum;
                                processes[i].remainingTime -= timeQuantum;
                            } else {
                                time += processes[i].remainingTime;
                                processes[i].completionTime = time;
                                processes[i].turnaroundTime = processes[i].completionTime - processes[i].arrivalTime;
                                processes[i].waitingTime = processes[i].turnaroundTime - processes[i].burstTime;
                                processes[i].remainingTime = 0;
                                completed++;
                            }
                        }
                    }
                }
            }
            
            void printResults(struct Process processes[], int n) {
                printf("\nProcess ID\tCompletion Time\tTurnaround Time\tWaiting Time\n");
                for (int i = 0; i < n; i++) {
                    printf("P%d\t\t%d\t\t%d\t\t%d\n", processes[i].id,
                           processes[i].completionTime,
                           processes[i].turnaroundTime,
                           processes[i].waitingTime);
                }
            
                float totalTurnaroundTime = 0, totalWaitingTime = 0;
                for (int i = 0; i < n; i++) {
                    totalTurnaroundTime += processes[i].turnaroundTime;
                    totalWaitingTime += processes[i].waitingTime;
                }
            
                printf("\nAverage Turnaround Time: %.2f\n", totalTurnaroundTime / n);
                printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
            }
            
            int main() {
                int n, timeQuantum;
            
                printf("Enter the number of processes: ");
                scanf("%d", &n);
            
                struct Process processes[n];
            
                for (int i = 0; i < n; i++) {
                    processes[i].id = i + 1;
                    printf("Enter arrival time and burst time for Process P%d: ", processes[i].id);
                    scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
                    processes[i].remainingTime = processes[i].burstTime;
                }
            
                timeQuantum=4;
            
                calculateTimes(processes, n, timeQuantum);
                printResults(processes, n);
            
                return 0;
            }
            
            3.Priority Scheduling Non-preemtive:
            #include <stdio.h>
            
            struct Process {
                int id;
                int arrivalTime;
                int burstTime;
                int priority;
                int completionTime;
                int turnaroundTime;
                int waitingTime;
            };
            
            void calculateTimes(struct Process processes[], int n) {
                int completed = 0;
                int currentTime = 0;
            
                while (completed < n) {
                    int highestPriorityIndex = -1;
                    int highestPriority = 9999;
            
                    for (int i = 0; i < n; i++) {
                        if (processes[i].arrivalTime <= currentTime && processes[i].burstTime > 0) {
                            if (processes[i].priority < highestPriority) {
                                highestPriority = processes[i].priority;
                                highestPriorityIndex = i;
                            }
                        }
                    }
            
                    if (highestPriorityIndex != -1) {
                        currentTime += processes[highestPriorityIndex].burstTime;
                        processes[highestPriorityIndex].completionTime = currentTime;
                        processes[highestPriorityIndex].turnaroundTime = processes[highestPriorityIndex].completionTime - processes[highestPriorityIndex].arrivalTime;
                        processes[highestPriorityIndex].waitingTime = processes[highestPriorityIndex].turnaroundTime - processes[highestPriorityIndex].burstTime;
            
                        processes[highestPriorityIndex].burstTime = 0;
                        completed++;
                    } else {
                        currentTime++;
                    }
                }
            }
            
            void printGanttChart(struct Process processes[], int n) {
                printf("\nGantt Chart:\n");
                for (int i = 0; i < n; i++) {
                    if (processes[i].completionTime != 0) {
                        printf("P%d ", processes[i].id);
                    }
                }
                printf("\n");
            
                printf("0 ");
                for (int i = 0; i < n; i++) {
                    if (processes[i].completionTime != 0) {
                        printf("%d ", processes[i].completionTime);
                    }
                }
                printf("\n");
            }
            
            int main() {
                int n;
            
                printf("Enter the number of processes: ");
                scanf("%d", &n);
            
                struct Process processes[n];
            
                for (int i = 0; i < n; i++) {
                    processes[i].id = i + 1;
                    printf("Enter arrival time, burst time, and priority for Process P%d: ", processes[i].id);
                    scanf("%d %d %d", &processes[i].arrivalTime, &processes[i].burstTime, &processes[i].priority);
                }
            
                calculateTimes(processes, n);
            
                printf("\nProcess ID\tArrival Time\tBurst Time\tPriority\tCompletion Time\tTurnaround Time\tWaiting Time\n");
                for (int i = 0; i < n; i++) {
                    printf("P%-10d\t%-12d\t%-10d\t%-8d\t%-15d\t%-15d\t%-10d\n", processes[i].id,
                           processes[i].arrivalTime,
                           processes[i].burstTime == 0 ? 0 : processes[i].burstTime,
                           processes[i].priority,
                           processes[i].completionTime,
                           processes[i].turnaroundTime,
                           processes[i].waitingTime);
                }
            
                float totalTurnaroundTime = 0, totalWaitingTime = 0;
                for (int i = 0; i < n; i++) {
                    totalTurnaroundTime += processes[i].turnaroundTime;
                    totalWaitingTime += processes[i].waitingTime;
                }
            
                printf("\nAverage Turnaround Time: %.2f\n", totalTurnaroundTime / n);
                printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
            
            
            
                return 0;
            }
            
            4.SJF(non-preemtive):
            #include <stdio.h>
            
            struct Process {
                int id;
                int arrivalTime;
                int burstTime;
                int completionTime;
                int turnaroundTime;
                int waitingTime;
            };
            
            int main() {
                int n;
            
                printf("Enter the number of processes: ");
                scanf("%d", &n);
            
                struct Process processes[n];
            
                // Input process details
                for (int i = 0; i < n; i++) {
                    processes[i].id = i + 1;
                    printf("Enter arrival time and burst time for Process P%d: ", processes[i].id);
                    scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
                    processes[i].completionTime = 0;  // Initialize completion time to 0
                }
            
                int currentTime = 0, completed = 0;
            
                // SJF Scheduling Logic
                while (completed < n) {
                    int minIndex = -1;
            
                    // Find the process with the shortest burst time that has arrived
                    for (int i = 0; i < n; i++) {
                        if (processes[i].arrivalTime <= currentTime && processes[i].completionTime == 0) {
                            if (minIndex == -1 || processes[i].burstTime < processes[minIndex].burstTime) {
                                minIndex = i;
                            }
                        }
                    }
            
                    if (minIndex != -1) {
                        currentTime += processes[minIndex].burstTime;
                        processes[minIndex].completionTime = currentTime;
                        processes[minIndex].turnaroundTime = processes[minIndex].completionTime - processes[minIndex].arrivalTime;
                        processes[minIndex].waitingTime = processes[minIndex].turnaroundTime - processes[minIndex].burstTime;
                        completed++;
                    } else {
                        currentTime++;
                    }
                }
            
                // Display the results
                printf("\nProcess\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\n");
                for (int i = 0; i < n; i++) {
                    printf("P%d\t%d\t%d\t%d\t\t%d\t\t%d\n",
                           processes[i].id,
                           processes[i].arrivalTime,
                           processes[i].burstTime,
                           processes[i].completionTime,
                           processes[i].turnaroundTime,
                           processes[i].waitingTime);
                }
            
                // Calculate and display averages
                float totalTurnaroundTime = 0, totalWaitingTime = 0;
                for (int i = 0; i < n; i++) {
                    totalTurnaroundTime += processes[i].turnaroundTime;
                    totalWaitingTime += processes[i].waitingTime;
                }
            
                printf("\nAverage Turnaround Time: %.2f\n", totalTurnaroundTime / n);
                printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
            
                return 0;
            }
            
            
            
            
            
            Q.13 Write a program to implement bankers algorithm Number of processes: 5 (P0 to P4) Resources: Resource A: Number of instances: 10 Resource B: Number of instances: 5 Resource C: Number of instances: 7
            #include <stdio.h>
            
            #define P 5 // Number of processes
            #define R 3 // Number of resources
            
            // Function to check if a state is safe
            int isSafe(int available[], int max[P][R], int allocation[P][R], int need[P][R]) {
                int work[R];
                int finish[P] = {0}; // 0 means not finished, 1 means finished
                int safeSequence[P];
                int index = 0;
            
                // Initialize work as available
                for (int i = 0; i < R; i++) {
                    work[i] = available[i];
                }
            
                while (1) {
                    int found = 0; // 0 means no process was found, 1 means a process was found
                    for (int i = 0; i < P; i++) {
                        if (finish[i] == 0) {
                            int canAllocate = 1; // Assume we can allocate
                            for (int j = 0; j < R; j++) {
                                if (need[i][j] > work[j]) {
                                    canAllocate = 0; // Can't allocate
                                    break;
                                }
                            }
                            if (canAllocate) {
                                // Allocate resources
                                for (int j = 0; j < R; j++) {
                                    work[j] += allocation[i][j];
                                }
                                safeSequence[index++] = i;
                                finish[i] = 1; // Mark as finished
                                found = 1;
                            }
                        }
                    }
                    if (!found) {
                        break;
                    }
                }
            
                for (int i = 0; i < P; i++) {
                    if (finish[i] == 0) {
                        printf("System is not in a safe state.\n");
                        return 0; // Not safe
                    }
                }
            
                printf("System is in a safe state.\nSafe Sequence: ");
                for (int i = 0; i < P; i++) {
                    printf("P%d ", safeSequence[i]);
                }
                printf("\n");
                return 1; // Safe
            }
            
            int main() {
                // Input data
                int allocation[P][R] = {
                    {0, 1, 0},
                    {2, 0, 0},
                    {3, 0, 2},
                    {2, 1, 1},
                    {0, 0, 2}
                };
            
                int max[P][R] = {
                    {7, 5, 3},
                    {3, 2, 2},
                    {9, 0, 2},
                    {2, 2, 2},
                    {4, 3, 3}
                };
            
                int available[R] = {3, 3, 2};
            
                // Calculate need matrix
                int need[P][R];
                for (int i = 0; i < P; i++) {
                    for (int j = 0; j < R; j++) {
                        need[i][j] = max[i][j] - allocation[i][j];
                    }
                }
            
                // Display the Need matrix
                printf("Need Matrix:\n");
                for (int i = 0; i < P; i++) {
                    for (int j = 0; j < R; j++) {
                        printf("%d ", need[i][j]);
                    }
                    printf("\n");
                }
            
                // Check if the system is in a safe state
                isSafe(available, max, allocation, need);
            
                return 0;
            }
            
            Q.14Write a program for deadlock detection algorithm for following example. 
            #include <stdio.h>
            
            #define P 5 // Number of processes
            #define R 3 // Number of resources
            
            void detectDeadlock(int allocation[P][R], int request[P][R], int available[R]) {
                int work[R];
                int finish[P] = {0}; // 0 means not finished, 1 means finished
                int deadlocked[P];
                int deadlockedCount = 0;
            
                // Initialize work as available
                for (int i = 0; i < R; i++) {
                    work[i] = available[i];
                }
            
                while (1) {
                    int found = 0; // Indicates if any process was able to proceed
                    for (int i = 0; i < P; i++) {
                        if (finish[i] == 0) { // If process is not yet finished
                            int canAllocate = 1; // Assume we can allocate resources
                            for (int j = 0; j < R; j++) {
                                if (request[i][j] > work[j]) {
                                    canAllocate = 0; // Cannot allocate resources
                                    break;
                                }
                            }
                            if (canAllocate) {
                                // Pretend to allocate resources to this process
                                for (int j = 0; j < R; j++) {
                                    work[j] += allocation[i][j];
                                }
                                finish[i] = 1; // Mark process as finished
                                found = 1;
                            }
                        }
                    }
                    if (!found) { // No process could proceed
                        break;
                    }
                }
            
                // Check for processes that could not finish
                for (int i = 0; i < P; i++) {
                    if (finish[i] == 0) {
                        deadlocked[deadlockedCount++] = i;
                    }
                }
            
                // Output the result
                if (deadlockedCount > 0) {
                    printf("Deadlock detected. The following processes are in deadlock:\n");
                    for (int i = 0; i < deadlockedCount; i++) {
                        printf("P%d ", deadlocked[i]);
                    }
                    printf("\n");
                } else {
                    printf("No deadlock detected. All processes can finish.\n");
                }
            }
            
            int main() {
                // Input data
                int allocation[P][R] = {
                    {0, 1, 0},
                    {2, 0, 0},
                    {3, 0, 3},
                    {2, 1, 1},
                    {0, 0, 2}
                };
            
                int request[P][R] = {
                    {0, 0, 0},
                    {2, 0, 2},
                    {0, 0, 0},
                    {1, 0, 0},
                    {0, 0, 2}
                };
            
                int available[R] = {0, 0, 0};
            
                // Check for deadlock
                detectDeadlock(allocation, request, available);
            
                return 0;
            }
            
            15. Following is the list of available blocks in the main memory and the process size for each process (P0 to P3).
            blockSize[]     = {100, 500, 200, 300, 600} processSize[] = {212, 417, 112, 426}
            Find which memory block is allocated to which process using following placement strategies:
            Vaibhav : 
            #include <stdio.h>
            
            #define BLOCK_COUNT 5
            #define PROCESS_COUNT 4
            
            void firstFit(int blockSize[], int processSize[]) {
                int allocation[PROCESS_COUNT];
                for (int i = 0; i < PROCESS_COUNT; i++)
                    allocation[i] = -1; // Initially, no process is allocated
            
                for (int i = 0; i < PROCESS_COUNT; i++) {
                    for (int j = 0; j < BLOCK_COUNT; j++) {
                        if (blockSize[j] >= processSize[i]) {
                            allocation[i] = j;
                            blockSize[j] -= processSize[i];
                            break;
                        }
                    }
                }
            
                printf("\nFirst Fit Allocation:\n");
                for (int i = 0; i < PROCESS_COUNT; i++) {
                    if (allocation[i] != -1)
                        printf("Process %d -> Block %d\n", i, allocation[i] + 1);
                    else
                        printf("Process %d -> Not Allocated\n", i);
                }
            }
            
            void worstFit(int blockSize[], int processSize[]) {
                int allocation[PROCESS_COUNT];
                for (int i = 0; i < PROCESS_COUNT; i++)
                    allocation[i] = -1;
            
                for (int i = 0; i < PROCESS_COUNT; i++) {
                    int worstIdx = -1;
                    for (int j = 0; j < BLOCK_COUNT; j++) {
                        if (blockSize[j] >= processSize[i]) {
                            if (worstIdx == -1 || blockSize[j] > blockSize[worstIdx]) {
                                worstIdx = j;
                            }
                        }
                    }
                    if (worstIdx != -1) {
                        allocation[i] = worstIdx;
                        blockSize[worstIdx] -= processSize[i];
                    }
                }
            
                printf("\nWorst Fit Allocation:\n");
                for (int i = 0; i < PROCESS_COUNT; i++) {
                    if (allocation[i] != -1)
                        printf("Process %d -> Block %d\n", i, allocation[i] + 1);
                    else
                        printf("Process %d -> Not Allocated\n", i);
                }
            }
            
            void bestFit(int blockSize[], int processSize[]) {
                int allocation[PROCESS_COUNT];
                for (int i = 0; i < PROCESS_COUNT; i++)
                    allocation[i] = -1;
            
                for (int i = 0; i < PROCESS_COUNT; i++) {
                    int bestIdx = -1;
                    for (int j = 0; j < BLOCK_COUNT; j++) {
                        if (blockSize[j] >= processSize[i]) {
                            if (bestIdx == -1 || blockSize[j] < blockSize[bestIdx]) {
                                bestIdx = j;
                            }
                        }
                    }
                    if (bestIdx != -1) {
                        allocation[i] = bestIdx;
                        blockSize[bestIdx] -= processSize[i];
                    }
                }
            
                printf("\nBest Fit Allocation:\n");
                for (int i = 0; i < PROCESS_COUNT; i++) {
                    if (allocation[i] != -1)
                        printf("Process %d -> Block %d\n", i, allocation[i] + 1);
                    else
                        printf("Process %d -> Not Allocated\n", i);
                }
            }
            
            int main() {
                int blockSize[BLOCK_COUNT] = {100, 500, 200, 300, 600};
                int processSize[PROCESS_COUNT] = {212, 417, 112, 426};
            
                // Copy original block sizes for each method
                int blockSizeFirstFit[BLOCK_COUNT], blockSizeWorstFit[BLOCK_COUNT], blockSizeBestFit[BLOCK_COUNT];
                for (int i = 0; i < BLOCK_COUNT; i++) {
                    blockSizeFirstFit[i] = blockSize[i];
                    blockSizeWorstFit[i] = blockSize[i];
                    blockSizeBestFit[i] = blockSize[i];
                }
            
                firstFit(blockSizeFirstFit, processSize);
                worstFit(blockSizeWorstFit, processSize);
                bestFit(blockSizeBestFit, processSize);
            
                return 0;
            }
            
            
            
            a.      First Fit
            #include <stdio.h>
            
            void first_fit(int block_size[], int blocks, int process_size[], int processes);
            
            int main() {
                int block_size[] = {100, 500, 200, 300, 600};
                int process_size[] = {212, 417, 112, 426};
                int blocks = sizeof(block_size) / sizeof(block_size[0]);
                int processes = sizeof(process_size) / sizeof(process_size[0]);
            
                printf("--- First Fit Allocation ---\n");
                first_fit(block_size, blocks, process_size, processes);
            
                return 0;
            }
            
            void first_fit(int block_size[], int blocks, int process_size[], int processes) {
                int allocation[processes];
            
                // Initialize allocation array
                for (int i = 0; i < processes; i++)
                    allocation[i] = -1;
            
                // Allocate memory blocks to processes using First Fit
                for (int i = 0; i < processes; i++) {
                    for (int j = 0; j < blocks; j++) {
                        if (block_size[j] >= process_size[i]) {
                            allocation[i] = j;           // Assign block j to process i
                            block_size[j] -= process_size[i]; // Reduce the available size of block j
                            break; // Stop searching for this process
                        }
                    }
                }
            
                // Print allocation result
                printf("Process No.\tProcess Size\tBlock No.\n");
                for (int i = 0; i < processes; i++) {
                    printf("%d\t\t%d\t\t", i + 1, process_size[i]);
                    if (allocation[i] != -1)
                        printf("%d\n", allocation[i] + 1); // Add 1 to match block numbering
                    else
                        printf("Not Allocated\n");
                }
            }
            
            
            
            
            
            b.     Worst fit     
            #include <stdio.h>
            
            void worst_fit(int block_size[], int blocks, int process_size[], int processes);
            
            int main() {
                int block_size[] = {100, 500, 200, 300, 600};
                int process_size[] = {212, 417, 112, 426};
                int blocks = sizeof(block_size) / sizeof(block_size[0]);
                int processes = sizeof(process_size) / sizeof(process_size[0]);
            
                printf("--- Worst Fit Allocation ---\n");
                worst_fit(block_size, blocks, process_size, processes);
            
                return 0;
            }
            
            void worst_fit(int block_size[], int blocks, int process_size[], int processes) {
                int allocation[processes];
            
                // Initialize allocation array
                for (int i = 0; i < processes; i++)
                    allocation[i] = -1;
            
                // Allocate memory blocks to processes using Worst Fit
                for (int i = 0; i < processes; i++) {
                    int worst_idx = -1;
            
                    // Find the block with the largest size that can accommodate the process
                    for (int j = 0; j < blocks; j++) {
                        if (block_size[j] >= process_size[i]) {
                            if (worst_idx == -1 || block_size[j] > block_size[worst_idx])
                                worst_idx = j;
                        }
                    }
            
                    // If a suitable block was found
                    if (worst_idx != -1) {
                        allocation[i] = worst_idx;         // Allocate the block to the process
                        block_size[worst_idx] -= process_size[i]; // Reduce the block size
                    }
                }
            
                // Print allocation result
                printf("Process No.\tProcess Size\tBlock No.\n");
                for (int i = 0; i < processes; i++) {
                    printf("%d\t\t%d\t\t", i + 1, process_size[i]);
                    if (allocation[i] != -1)
                        printf("%d\n", allocation[i] + 1); // Add 1 to match block numbering
                    else
                        printf("Not Allocated\n");
                }
            }
            
            
              
            c. Best fit
            #include <stdio.h>
            
            void best_fit(int block_size[], int blocks, int process_size[], int processes);
            
            int main() {
                int block_size[] = {100, 500, 200, 300, 600};
                int process_size[] = {212, 417, 112, 426};
                int blocks = sizeof(block_size) / sizeof(block_size[0]);
                int processes = sizeof(process_size) / sizeof(process_size[0]);
            
                printf("--- Best Fit Allocation ---\n");
                best_fit(block_size, blocks, process_size, processes);
            
                return 0;
            }
            
            void best_fit(int block_size[], int blocks, int process_size[], int processes) {
                int allocation[processes];
            
                // Initialize allocation array
                for (int i = 0; i < processes; i++)
                    allocation[i] = -1;
            
                // Process each process
                for (int i = 0; i < processes; i++) {
                    int best_idx = -1;
            
                    // Find the best fit block for the current process
                    for (int j = 0; j < blocks; j++) {
                        if (block_size[j] >= process_size[i]) {
                            if (best_idx == -1 || block_size[j] < block_size[best_idx])
                                best_idx = j;
                        }
                    }
            
                    // If a suitable block was found
                    if (best_idx != -1) {
                        allocation[i] = best_idx;         // Allocate the block to the process
                        block_size[best_idx] -= process_size[i]; // Reduce the available size of the block
                    }
                }
            
                // Print allocation result
                printf("Process No.\tProcess Size\tBlock No.\n");
                for (int i = 0; i < processes; i++) {
                    printf("%d\t\t%d\t\t", i + 1, process_size[i]);
                    if (allocation[i] != -1)
                        printf("%d\n", allocation[i] + 1);
                    else
                        printf("Not Allocated\n");
                }
            }
            
            
            
            d.Next Fit
            #include <stdio.h>
            #include <stdbool.h>
            
            void next_fit(int block_size[], int blocks, int process_size[], int processes);
            
            int main() {
                int block_size[] = {100, 500, 200, 300, 600};
                int process_size[] = {212, 417, 112, 426};
                int blocks = sizeof(block_size) / sizeof(block_size[0]);
                int processes = sizeof(process_size) / sizeof(process_size[0]);
            
                printf("--- Next Fit Allocation ---\n");
                next_fit(block_size, blocks, process_size, processes);
            
                return 0;
            }
            
            void next_fit(int block_size[], int blocks, int process_size[], int processes) {
                int allocation[processes];
            
                // Initialize allocation array
                for (int i = 0; i < processes; i++)
                    allocation[i] = -1;
            
                int last_alloc = 0; // Start from the first block
            
                // Allocate memory blocks to processes using Next Fit
                for (int i = 0; i < processes; i++) {
                    bool allocated = false;
            
                    // Loop through the blocks starting from the last allocated position
                    for (int j = 0; j < blocks; j++) {
                        int index = (last_alloc + j) % blocks; // Circular traversal
                        if (block_size[index] >= process_size[i]) {
                            allocation[i] = index;             // Assign block to the process
                            block_size[index] -= process_size[i]; // Reduce block size
                            last_alloc = (index + 1) % blocks; // Update last allocated position
                            allocated = true;
                            break;
                        }
                    }
            
                    // If no suitable block is found, the process remains unallocated
                    if (!allocated) {
                        allocation[i] = -1;
                    }
                }
            
                // Print allocation result
                printf("Process No.\tProcess Size\tBlock No.\n");
                for (int i = 0; i < processes; i++) {
                    printf("%d\t\t%d\t\t", i + 1, process_size[i]);
                    if (allocation[i] != -1)
                        printf("%d\n", allocation[i] + 1); // Add 1 to match block numbering
                    else
                        printf("Not Allocated\n");
                }
            }
            
            
            16. Following is the list of available blocks in the main memory and the process size for each process (P0 to P3). blockSize[] = {100, 500, 200, 300, 600} processSize[] = {212, 417, 112, 426} Find which memory block is allocated to which process using following placement strategies: 1) First Fit 2) Next fit 3) Worst fit
            Vaibhav2: 
            #include <stdio.h>
            
            #define BLOCK_COUNT 5
            #define PROCESS_COUNT 4
            
            void firstFit(int blockSize[], int processSize[]) {
                int allocation[PROCESS_COUNT];
                for (int i = 0; i < PROCESS_COUNT; i++)
                    allocation[i] = -1; // Initially, no process is allocated
            
                for (int i = 0; i < PROCESS_COUNT; i++) {
                    for (int j = 0; j < BLOCK_COUNT; j++) {
                        if (blockSize[j] >= processSize[i]) {
                            allocation[i] = j;
                            blockSize[j] -= processSize[i];
                            break;
                        }
                    }
                }
            
                printf("\nFirst Fit Allocation:\n");
                for (int i = 0; i < PROCESS_COUNT; i++) {
                    if (allocation[i] != -1)
                        printf("Process %d -> Block %d\n", i, allocation[i] + 1);
                    else
                        printf("Process %d -> Not Allocated\n", i);
                }
            }
            
            void nextFit(int blockSize[], int processSize[]) {
                int allocation[PROCESS_COUNT];
                for (int i = 0; i < PROCESS_COUNT; i++)
                    allocation[i] = -1; // Initially, no process is allocated
            
                int startIndex = 0; // Pointer to track the last allocated block
                for (int i = 0; i < PROCESS_COUNT; i++) {
                    int allocated = 0; // To track if a block is found
                    for (int j = 0; j < BLOCK_COUNT; j++) {
                        int index = (startIndex + j) % BLOCK_COUNT; // Wrap around
                        if (blockSize[index] >= processSize[i]) {
                            allocation[i] = index;
                            blockSize[index] -= processSize[i];
                            startIndex = index + 1; // Move the pointer to next block
                            allocated = 1;
                            break;
                        }
                    }
                    if (!allocated)
                        startIndex = 0; // Reset if no block is found
                }
            
                printf("\nNext Fit Allocation:\n");
                for (int i = 0; i < PROCESS_COUNT; i++) {
                    if (allocation[i] != -1)
                        printf("Process %d -> Block %d\n", i, allocation[i] + 1);
                    else
                        printf("Process %d -> Not Allocated\n", i);
                }
            }
            
            void worstFit(int blockSize[], int processSize[]) {
                int allocation[PROCESS_COUNT];
                for (int i = 0; i < PROCESS_COUNT; i++)
                    allocation[i] = -1; // Initially, no process is allocated
            
                for (int i = 0; i < PROCESS_COUNT; i++) {
                    int worstIdx = -1;
                    for (int j = 0; j < BLOCK_COUNT; j++) {
                        if (blockSize[j] >= processSize[i]) {
                            if (worstIdx == -1 || blockSize[j] > blockSize[worstIdx]) {
                                worstIdx = j;
                            }
                        }
                    }
                    if (worstIdx != -1) {
                        allocation[i] = worstIdx;
                        blockSize[worstIdx] -= processSize[i];
                    }
                }
            
                printf("\nWorst Fit Allocation:\n");
                for (int i = 0; i < PROCESS_COUNT; i++) {
                    if (allocation[i] != -1)
                        printf("Process %d -> Block %d\n", i, allocation[i] + 1);
                    else
                        printf("Process %d -> Not Allocated\n", i);
                }
            }
            
            int main() {
                int blockSize[BLOCK_COUNT] = {100, 500, 200, 300, 600};
                int processSize[PROCESS_COUNT] = {212, 417, 112, 426};
            
                // Copy original block sizes for each method
                int blockSizeFirstFit[BLOCK_COUNT], blockSizeNextFit[BLOCK_COUNT], blockSizeWorstFit[BLOCK_COUNT];
                for (int i = 0; i < BLOCK_COUNT; i++) {
                    blockSizeFirstFit[i] = blockSize[i];
                    blockSizeNextFit[i] = blockSize[i];
                    blockSizeWorstFit[i] = blockSize[i];
                }
            
                firstFit(blockSizeFirstFit, processSize);
                nextFit(blockSizeNextFit, processSize);
                worstFit(blockSizeWorstFit, processSize);
            
                return 0;
            }
            
            Q20. Consider the page reference string as 7,1,0,2,0,3,0,4,2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1 with 3-page frames. Find the total number of page faults using following page replacement algorithms:
            1)     Least recently used
            #include <stdio.h>
            
            int findLRU(int time[], int n) {
                int min = time[0], pos = 0;
            
                for (int i = 1; i < n; i++) {
                    if (time[i] < min) {
                        min = time[i];
                        pos = i;
                    }
                }
                return pos;
            }
            
            int lruPageReplacement(int reference[], int referenceLength, int numFrames) {
                int frames[numFrames];
                int time[numFrames]; // Tracks when each frame was last used
                int pageFaults = 0;
                int counter = 0;
            
                // Initialize frames and time arrays
                for (int i = 0; i < numFrames; i++) {
                    frames[i] = -1;
                    time[i] = 0;
                }
            
                for (int i = 0; i < referenceLength; i++) {
                    int currentPage = reference[i];
                    int found = 0;
            
                    // Check if the page is already in frames
                    for (int j = 0; j < numFrames; j++) {
                        if (frames[j] == currentPage) {
                            found = 1;
                            time[j] = ++counter; // Update time for the recently used page
                            break;
                        }
                    }
            
                    if (!found) {
                        // Find the least recently used page to replace
                        int pos = findLRU(time, numFrames);
                        frames[pos] = currentPage;
                        time[pos] = ++counter; // Update time for the new page
                        pageFaults++;
                    }
                }
            
                return pageFaults;
            }
            
            int main() {
                int reference[] = {7, 1, 0, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1};
                int referenceLength = sizeof(reference) / sizeof(reference[0]);
                int numFrames = 3;
            
                int totalPageFaults = lruPageReplacement(reference, referenceLength, numFrames);
            
                printf("Total Page Faults using LRU: %d\n", totalPageFaults);
            
                return 0;
            }
            
            
            2)     Optimal
            #include <stdio.h>
            
            int findOptimalPage(int reference[], int pages[], int currentIndex, int numFrames, int referenceLength) {
                int farthest = currentIndex, pageToReplace = -1;
            
                for (int i = 0; i < numFrames; i++) {
                    int j;
                    for (j = currentIndex; j < referenceLength; j++) {
                        if (pages[i] == reference[j]) {
                            if (j > farthest) {
                                farthest = j;
                                pageToReplace = i;
                            }
                            break;
                        }
                    }
                    // If page is not referenced in the future
                    if (j == referenceLength) {
                        return i;
                    }
                }
            
                // If all pages are referenced, replace the farthest one
                return (pageToReplace == -1) ? 0 : pageToReplace;
            }
            
            int optimalPageReplacement(int reference[], int referenceLength, int numFrames) {
                int pages[numFrames];
                int pageFaults = 0;
            
                for (int i = 0; i < numFrames; i++) {
                    pages[i] = -1; // Initialize pages with -1 (empty)
                }
            
                for (int i = 0; i < referenceLength; i++) {
                    int found = 0;
            
                    // Check if the current page is already in frames
                    for (int j = 0; j < numFrames; j++) {
                        if (pages[j] == reference[i]) {
                            found = 1;
                            break;
                        }
                    }
            
                    if (!found) {
                        // Find the page to replace
                        if (i < numFrames) {
                            pages[i] = reference[i];
                        } else {
                            int replaceIndex = findOptimalPage(reference, pages, i + 1, numFrames, referenceLength);
                            pages[replaceIndex] = reference[i];
                        }
                        pageFaults++;
                    }
                }
            
                return pageFaults;
            }
            
            int main() {
                int reference[] = {7, 1, 0, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1};
                int referenceLength = sizeof(reference) / sizeof(reference[0]);
                int numFrames = 3;
            
                int totalPageFaults = optimalPageReplacement(reference, referenceLength, numFrames);
            
                printf("Total Page Faults: %d\n", totalPageFaults);
            
                return 0;
            }
            
            
            3)FIFO
            #include <stdio.h>
            #include <stdbool.h>
            
            int fifoPageReplacement(int reference[], int referenceLength, int numFrames) {
                int frames[numFrames];
                int pageFaults = 0;
                int front = 0; // Points to the oldest page in the frames
            
                // Initialize all frames as empty
                for (int i = 0; i < numFrames; i++) {
                    frames[i] = -1;
                }
            
                for (int i = 0; i < referenceLength; i++) {
                    int currentPage = reference[i];
                    bool found = false;
            
                    // Check if the page is already in the frames
                    for (int j = 0; j < numFrames; j++) {
                        if (frames[j] == currentPage) {
                            found = true;
                            break;
                        }
                    }
            
                    if (!found) {
                        // Replace the oldest page using FIFO policy
                        frames[front] = currentPage;
                        front = (front + 1) % numFrames; // Update the front pointer circularly
                        pageFaults++;
                    }
                }
            
                return pageFaults;
            }
            
            int main() {
                int reference[] = {7, 1, 0, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1};
                int referenceLength = sizeof(reference) / sizeof(reference[0]);
                int numFrames = 3;
            
                int totalPageFaults = fifoPageReplacement(reference, referenceLength, numFrames);
            
                printf("Total Page Faults: %d\n", totalPageFaults);
            
                return 0;
            }
            
            
            
            Q(22-27). Consider the order of request for cylinder access of the disk is - (98, 183, 37, 122, 14, 124, 65, 67) and current position of Read/Write head is: 53. Find the total head movements to access the data on the cylinder using following disk scheduling algorithms:
            
            1)FCFS
            #include <stdio.h>
            #include <stdlib.h>
            
            void calculateFCFS(int requests[], int num_requests, int initial_position) {
                int total_distance = 0;
                int current_position = initial_position;
            
                printf("Processing Steps:\n");
            
                for (int i = 0; i < num_requests; i++) {
                    int distance = abs(current_position - requests[i]);
                    total_distance += distance;
                    printf("Move to %d: Distance from %d to %d = %d\n", requests[i], current_position, requests[i], distance);
                    current_position = requests[i];
                }
            
                printf("\nTotal Distance: %d\n", total_distance);
            }
            
            int main() {
                int initial_position = 53;
                int requests[] = {98, 183, 37, 122, 14, 124, 65, 67};
                int num_requests = sizeof(requests) / sizeof(requests[0]);
            
                calculateFCFS(requests, num_requests, initial_position);
            
                return 0;
            }
            
            
            
            
            
            
            2)SSTF
            #include <stdio.h>
            #include <stdlib.h>
            #include <stdbool.h>
            
            void calculateSSTF(int requests[], int num_requests, int initial_position) {
                int total_distance = 0;
                int current_position = initial_position;
                bool serviced[num_requests];
                for (int i = 0; i < num_requests; i++) {
                    serviced[i] = false;
                }
            
                printf("SSTF Processing Steps:\n");
            
                for (int i = 0; i < num_requests; i++) {
                    int closest_idx = -1;
                    int closest_distance = __INT_MAX__;
            
                    for (int j = 0; j < num_requests; j++) {
                        if (!serviced[j]) {
                            int distance = abs(current_position - requests[j]);
                            if (distance < closest_distance) {
                                closest_distance = distance;
                                closest_idx = j;
                            }
                        }
                    }
            
                    if (closest_idx != -1) {
                        printf("Move to %d: Distance from %d to %d = %d\n", requests[closest_idx], current_position, requests[closest_idx], closest_distance);
                        total_distance += closest_distance;
                        current_position = requests[closest_idx];
                        serviced[closest_idx] = true;
                    }
                }
            
                printf("\nTotal Distance: %d\n", total_distance);
            }
            
            int main() {
                // Hardcoded values from the problem statement
                int initial_position = 53;
                int requests[] = {98, 183, 37, 122, 14, 124, 65, 67};
                int num_requests = sizeof(requests) / sizeof(requests[0]);
            
                calculateSSTF(requests, num_requests, initial_position);
            
                return 0;
            }
            
            
            3)Scan
            #include <stdio.h>
            #include <stdlib.h>
            
            #define MAX_CYLINDERS 200
            
            // Function to sort an array of integers in ascending order
            void sort_requests(int requests[], int n) {
                // Loop through the array
                for (int i = 0; i < n - 1; i++) {
                    // Loop through the array again, comparing each pair of adjacent elements
                    for (int j = 0; j < n - i - 1; j++) {
                        // If the current element is greater than the next element, swap them
                        if (requests[j] > requests[j + 1]) {
                            int temp = requests[j];
                            requests[j] = requests[j + 1];
                            requests[j + 1] = temp;
                        }
                    }
                }
            }
            
            void scan(int requests[], int n, int initial_position) {
                // Initialize total_movement to 0
                int total_movement = 0;
            
                // Sort the requests array
                sort_requests(requests, n);
            
                // Find the index of the first request that is greater than or equal to the initial position
                int current_index = 0;
                for (int i = 0; i < n; i++) {
                    if (requests[i] >= initial_position) {
                        current_index = i;
                        break;
                    }
                }
            
                printf("Request sequence:\n");
            
                    for (int i = current_index; i < n; i++) {
                        total_movement += abs(initial_position - requests[i]);
                        initial_position = requests[i];
                        printf("%d ", requests[i]);
                    }
                    total_movement += abs(initial_position - (MAX_CYLINDERS - 1));
                    initial_position = MAX_CYLINDERS - 1;
            
                    for (int i = current_index - 1; i >= 0; i--) {
                        total_movement += abs(initial_position - requests[i]);
                        initial_position = requests[i];
                        printf("%d ", requests[i]);
                    }
                    total_movement += abs(initial_position - 0);
                    initial_position = 0;
                printf("\n");
                printf("\nTotal Head Movement: %d\n", total_movement);
            }
            
            int main() {
                int requests[] = {98, 183, 37, 122, 14, 124, 65, 67};
                int n = sizeof(requests) / sizeof(requests[0]);
                int initial_position = 53;
              // Outward movement pre-set
            
                printf("Initial Position: %d\n", initial_position);
                printf("\n");
            
                scan(requests, n, initial_position);
            
                return 0;
            }
            
            
            
            4)C-Scan
            #include <stdio.h>
            #include <stdlib.h>
            
            #define MAX_CYLINDERS 200
            
            void sort_requests(int requests[], int n) {
                for (int i = 0; i < n - 1; i++) {
                    for (int j = 0; j < n - i - 1; j++) {
                        if (requests[j] > requests[j + 1]) {
                            int temp = requests[j];
                            requests[j] = requests[j + 1];
                            requests[j + 1] = temp;
                        }
                    }
                }
            }
            
            void cscan(int requests[], int n, int initial_position) {
                int total_movement = 0;
                int i;
            
                // Sort the request array
                sort_requests(requests, n);
            
                // Find the starting point
                int current_index = 0;
                for (i = 0; i < n; i++) {
                    if (requests[i] >= initial_position) {
                        current_index = i;
                        break;
                    }
                }
            
                printf("Request sequence:\n");
            
               
                    // Service requests moving outward
                for (i = current_index; i < n; i++) {
                        total_movement += abs(initial_position - requests[i]);
                        initial_position = requests[i];
                        printf("%d ", requests[i]);
                    }
            
                    // Move to the highest cylinder
                    total_movement += abs(initial_position - (MAX_CYLINDERS - 1));
                    initial_position = MAX_CYLINDERS - 1;
                    printf("%d ", initial_position);
            
                    // Jump to the lowest cylinder (0)
                    total_movement += abs(initial_position - 0);
                    initial_position = 0;
                    printf("%d ", initial_position);
            
                    // Service requests from the beginning
                    for (i = 0; i < current_index; i++) {
                        total_movement += abs(initial_position - requests[i]);
                        initial_position = requests[i];
                        printf("%d ", requests[i]);
                    }
            
                 
                printf("\nTotal Head Movement: %d\n", total_movement);
            }
            
            int main() {
                int requests[] = {98, 183, 37, 122, 14, 124, 65, 67};
                int n = sizeof(requests) / sizeof(requests[0]);
                int initial_position = 53;
               
                printf("Initial Position: %d\n", initial_position);
                printf("\n");
            
                cscan(requests, n, initial_position);
            
                return 0;
            }
            
            
            
            
            Q28. Implement  the  following  algorithms:
            1)     FCFS-  CPU  scheduling  algo
            #include <stdio.h>
            
            struct Process {
                int id;
                int arrivalTime;
                int burstTime;
                int completionTime;
                int turnaroundTime;
                int waitingTime;
            };
            
            void printGanttChart(struct Process processes[], int n) {
                printf("\nGantt Chart:\n");
                printf("|");
                for (int i = 0; i < n; i++) {
                    printf(" P%d |", processes[i].id);
                }
                printf("\n0");
                for (int i = 0; i < n; i++) {
                    printf("    %d", processes[i].completionTime);
                }
                printf("\n");
            }
            
            int main() {
                int n;
            
                printf("Enter the number of processes: ");
                scanf("%d", &n);
            
                struct Process processes[n];
            
                for (int i = 0; i < n; i++) {
                    processes[i].id = i + 1;
                    printf("Enter arrival time and burst time for Process P%d: ", processes[i].id);
                    scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
                }
            
                // Sort processes by arrival time
                for (int i = 0; i < n - 1; i++) {
                    for (int j = i + 1; j < n; j++) {
                        if (processes[i].arrivalTime > processes[j].arrivalTime) {
                            struct Process temp = processes[i];
                            processes[i] = processes[j];
                            processes[j] = temp;
                        }
                    }
                }
            
                // Compute completion, turnaround, and waiting times
                int currentTime = 0;
                for (int i = 0; i < n; i++) {
                    if (currentTime < processes[i].arrivalTime) {
                        currentTime = processes[i].arrivalTime;
                    }
                    processes[i].completionTime = currentTime + processes[i].burstTime;
                    currentTime = processes[i].completionTime;
                    processes[i].turnaroundTime = processes[i].completionTime - processes[i].arrivalTime;
                    processes[i].waitingTime = processes[i].turnaroundTime - processes[i].burstTime;
                }
            
                // Print process details
                printf("\nProcess ID\tArrival Time\tBurst Time\tCompletion Time\tTurnaround Time\tWaiting Time\n");
                for (int i = 0; i < n; i++) {
                    printf("P%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d\n",
                           processes[i].id,
                           processes[i].arrivalTime,
                           processes[i].burstTime,
                           processes[i].completionTime,
                           processes[i].turnaroundTime,
                           processes[i].waitingTime);
                }
            
                // Calculate and print averages
                float totalTurnaroundTime = 0, totalWaitingTime = 0;
                for (int i = 0; i < n; i++) {
                    totalTurnaroundTime += processes[i].turnaroundTime;
                    totalWaitingTime += processes[i].waitingTime;
                }
                printf("\nAverage Turnaround Time: %.2f\n", totalTurnaroundTime / n);
                printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
            
                // Print Gantt chart
                printGanttChart(processes, n);
            
                return 0;
            }
            
            
            
            2)     Optimal  –page  replacement  algo  –( Consider the page reference string as 7,1,0,2,0,3,0,4,2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1 with 3-page frames. Find   the total number of page faults)
            #include <stdio.h>
            
            int findOptimalPage(int reference[], int pages[], int currentIndex, int numFrames, int referenceLength) {
                int farthest = currentIndex, pageToReplace = -1;
            
                for (int i = 0; i < numFrames; i++) {
                    int j;
                    for (j = currentIndex; j < referenceLength; j++) {
                        if (pages[i] == reference[j]) {
                            if (j > farthest) {
                                farthest = j;
                                pageToReplace = i;
                            }
                            break;
                        }
                    }
                    // If page is not referenced in the future
                    if (j == referenceLength) {
                        return i;
                    }
                }
            
                // If all pages are referenced, replace the farthest one
                return (pageToReplace == -1) ? 0 : pageToReplace;
            }
            
            int optimalPageReplacement(int reference[], int referenceLength, int numFrames) {
                int pages[numFrames];
                int pageFaults = 0;
            
                for (int i = 0; i < numFrames; i++) {
                    pages[i] = -1; // Initialize pages with -1 (empty)
                }
            
                for (int i = 0; i < referenceLength; i++) {
                    int found = 0;
            
                    // Check if the current page is already in frames
                    for (int j = 0; j < numFrames; j++) {
                        if (pages[j] == reference[i]) {
                            found = 1;
                            break;
                        }
                    }
            
                    if (!found) {
                        // Find the page to replace
                        if (i < numFrames) {
                            pages[i] = reference[i];
                        } else {
                            int replaceIndex = findOptimalPage(reference, pages, i + 1, numFrames, referenceLength);
                            pages[replaceIndex] = reference[i];
                        }
                        pageFaults++;
                    }
                }
            
                return pageFaults;
            }
            
            int main() {
                int reference[] = {7, 1, 0, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1};
                int referenceLength = sizeof(reference) / sizeof(reference[0]);
                int numFrames = 3;
            
                int totalPageFaults = optimalPageReplacement(reference, referenceLength, numFrames);
            
                printf("Total Page Faults: %d\n", totalPageFaults);
            
                return 0;
            }
            
            Q29. Implement  the  following  algorithms:
            1)     SJF-  CPU  scheduling  algo
            Non-pre
            #include <stdio.h>
            
            struct Process {
                int id;
                int arrivalTime;
                int burstTime;
                int completionTime;
                int turnaroundTime;
                int waitingTime;
            };
            
            void calculateTimes(struct Process processes[], int n) {
                int currentTime = 0;
                int completed = 0;
                int minIndex;
            
                while (completed < n) {
                    minIndex = -1;
                   
                   
                    for (int i = 0; i < n; i++) {
                        if (processes[i].arrivalTime <= currentTime && processes[i].completionTime == 0) {
                            if (minIndex == -1 || processes[i].burstTime < processes[minIndex].burstTime) {
                                minIndex = i;
                            }
                        }
                    }
            
                    if (minIndex != -1) {
                        currentTime += processes[minIndex].burstTime;
                        processes[minIndex].completionTime = currentTime;
                        processes[minIndex].turnaroundTime = processes[minIndex].completionTime - processes[minIndex].arrivalTime;
                        processes[minIndex].waitingTime = processes[minIndex].turnaroundTime - processes[minIndex].burstTime;
                        completed++;
                    } else {
                        currentTime++;
                    }
                }
            }
            
            void printGanttChart(struct Process processes[], int n) {
                printf("\nGantt Chart:\n");
                for (int i = 0; i < n; i++) {
                    if (processes[i].completionTime != 0) {
                        printf("P%d ", processes[i].id);
                    }
                }
                printf("\n");
            
                printf("0 ");
                for (int i = 0; i < n; i++) {
                    if (processes[i].completionTime != 0) {
                        printf("%d ", processes[i].completionTime);
                    }
                }
                printf("\n");
            }
            
            int main() {
                int n;
            
                printf("Enter the number of processes: ");
                scanf("%d", &n);
            
                struct Process processes[n];
            
                for (int i = 0; i < n; i++) {
                    processes[i].id = i + 1;
                    printf("Enter arrival time and burst time for Process P%d: ", processes[i].id);
                    scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
                    processes[i].completionTime = 0;
                }
            
                calculateTimes(processes, n);
            
                printf("\nProcess ID\tArrival Time\tBurst Time\tCompletion Time\tTurnaround Time\tWaiting Time\n");
                for (int i = 0; i < n; i++) {
                    printf("P%-10d\t%-12d\t%-10d\t%-15d\t%-15d\t%-10d\n", processes[i].id,
                           processes[i].arrivalTime,
                           processes[i].burstTime,
                           processes[i].completionTime,
                           processes[i].turnaroundTime,
                           processes[i].waitingTime);
                }
            
                float totalTurnaroundTime = 0, totalWaitingTime = 0;
                for (int i = 0; i < n; i++) {
                    totalTurnaroundTime += processes[i].turnaroundTime;
                    totalWaitingTime += processes[i].waitingTime;
                }
            
                printf("\nAverage Turnaround Time: %.2f\n", totalTurnaroundTime / n);
                printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
            
                printGanttChart(processes, n);
            
                return 0;
            }
            
            Pre
            #include <stdio.h>
            
            struct Process {
                int id;
                int arrivalTime;
                int burstTime;
                int remainingTime;
                int completionTime;
                int turnaroundTime;
                int waitingTime;
            };
            
            void calculateTimes(struct Process processes[], int n) {
                int currentTime = 0;
                int completed = 0;
            
                while (completed < n) {
                    int minIndex = -1;
                    int minRemainingTime = 9999;
            
                    for (int i = 0; i < n; i++) {
                        if (processes[i].arrivalTime <= currentTime && processes[i].remainingTime > 0) {
                            if (processes[i].remainingTime < minRemainingTime) {
                                minRemainingTime = processes[i].remainingTime;
                                minIndex = i;
                            }
                        }
                    }
            
                    if (minIndex != -1) {
                        processes[minIndex].remainingTime--;
                        currentTime++;
            
                        if (processes[minIndex].remainingTime == 0) {
                            processes[minIndex].completionTime = currentTime;
                            processes[minIndex].turnaroundTime = processes[minIndex].completionTime - processes[minIndex].arrivalTime;
                            processes[minIndex].waitingTime = processes[minIndex].turnaroundTime - processes[minIndex].burstTime;
                            completed++;
                        }
                    } else {
                        currentTime++;
                    }
                }
            }
            
            void printGanttChart(struct Process processes[], int n) {
                printf("\nGantt Chart:\n");
                for (int i = 0; i < n; i++) {
                    if (processes[i].completionTime != 0) {
                        printf("P%d ", processes[i].id);
                    }
                }
                printf("\n");
            
                printf("0 ");
                for (int i = 0; i < n; i++) {
                    if (processes[i].completionTime != 0) {
                        printf("%d ", processes[i].completionTime);
                    }
                }
                printf("\n");
            }
            
            int main() {
                int n;
            
                printf("Enter the number of processes: ");
                scanf("%d", &n);
            
                struct Process processes[n];
            
                for (int i = 0; i < n; i++) {
                    processes[i].id = i + 1;
                    printf("Enter arrival time and burst time for Process P%d: ", processes[i].id);
                    scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
                    processes[i].remainingTime = processes[i].burstTime;
                }
            
                calculateTimes(processes, n);
            
                printf("\nProcess ID\tArrival Time\tBurst Time\tCompletion Time\tTurnaround Time\tWaiting Time\n");
                for (int i = 0; i < n; i++) {
                    printf("P%-10d\t%-12d\t%-10d\t%-15d\t%-15d\t%-10d\n", processes[i].id,
                           processes[i].arrivalTime,
                           processes[i].burstTime,
                           processes[i].completionTime,
                           processes[i].turnaroundTime,
                           processes[i].waitingTime);
                }
            
                float totalTurnaroundTime = 0, totalWaitingTime = 0;
                for (int i = 0; i < n; i++) {
                    totalTurnaroundTime += processes[i].turnaroundTime;
                    totalWaitingTime += processes[i].waitingTime;
                }
            
                printf("\nAverage Turnaround Time: %.2f\n", totalTurnaroundTime / n);
                printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
            
                printGanttChart(processes, n);
            
                return 0;
            }
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            2)     FIFO  –page  replacement  algo  –( Consider the page reference string as
            7,1,0,2,0,3,0,4,2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1 with 3-page frames. Find   the total number of page faults)
            #include <stdio.h>
            #include <stdbool.h>
            
            int fifoPageReplacement(int reference[], int referenceLength, int numFrames) {
                int frames[numFrames];
                int pageFaults = 0;
                int front = 0; // Points to the oldest page in the frames
            
                // Initialize all frames as empty
                for (int i = 0; i < numFrames; i++) {
                    frames[i] = -1;
                }
            
                for (int i = 0; i < referenceLength; i++) {
                    int currentPage = reference[i];
                    bool found = false;
            
                    // Check if the page is already in the frames
                    for (int j = 0; j < numFrames; j++) {
                        if (frames[j] == currentPage) {
                            found = true;
                            break;
                        }
                    }
            
                    if (!found) {
                        // Replace the oldest page using FIFO policy
                        frames[front] = currentPage;
                        front = (front + 1) % numFrames; // Update the front pointer circularly
                        pageFaults++;
                    }
                }
            
                return pageFaults;
            }
            
            int main() {
                int reference[] = {7, 1, 0, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1};
                int referenceLength = sizeof(reference) / sizeof(reference[0]);
                int numFrames = 3;
            
                int totalPageFaults = fifoPageReplacement(reference, referenceLength, numFrames);
            
                printf("Total Page Faults: %d\n", totalPageFaults);
            
                return 0;
            }
            
            
            
            Q30. Implement  the  following  algorithms:
            3)     Round  Robin-  CPU  scheduling  algo(time  slice  =4ms)
            #include <stdio.h>
            #include <stdbool.h>
            
            // Define a structure to represent each process
            struct Process {
                int id;
                int arrivalTime;
                int burstTime;
                int remainingTime;
                int completionTime;
                int turnaroundTime;
                int waitingTime;
            };
            
            // Function to calculate scheduling times
            void calculateTimes(struct Process processes[], int n, int timeQuantum) {
                int time = 0;      // Current time
                int completed = 0; // Number of processes completed
            
                while (completed < n) {
                    bool processExecuted = false;
            
                    for (int i = 0; i < n; i++) {
                        if (processes[i].remainingTime > 0 && processes[i].arrivalTime <= time) {
                            processExecuted = true;
            
                            // If the remaining time is greater than the time quantum
                            if (processes[i].remainingTime > timeQuantum) {
                                time += timeQuantum;
                                processes[i].remainingTime -= timeQuantum;
                            } else {
                                // If remaining time is less than or equal to the time quantum
                                time += processes[i].remainingTime;
                                processes[i].completionTime = time;
                                processes[i].turnaroundTime = processes[i].completionTime - processes[i].arrivalTime;
                                processes[i].waitingTime = processes[i].turnaroundTime - processes[i].burstTime;
                                processes[i].remainingTime = 0; // Mark as completed
                                completed++;
                            }
                        }
                    }
            
                    // If no process was executed, increment time to the next arrival
                    if (!processExecuted) {
                        time++;
                    }
                }
            }
            
            // Function to print results
            void printResults(struct Process processes[], int n) {
                printf("\nProcess ID\tArrival Time\tBurst Time\tCompletion Time\tTurnaround Time\tWaiting Time\n");
                for (int i = 0; i < n; i++) {
                    printf("P%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d\n", processes[i].id,
                           processes[i].arrivalTime, processes[i].burstTime,
                           processes[i].completionTime, processes[i].turnaroundTime,
                           processes[i].waitingTime);
                }
            
                // Calculate average turnaround and waiting times
                float totalTurnaroundTime = 0, totalWaitingTime = 0;
                for (int i = 0; i < n; i++) {
                    totalTurnaroundTime += processes[i].turnaroundTime;
                    totalWaitingTime += processes[i].waitingTime;
                }
            
                printf("\nAverage Turnaround Time: %.2f\n", totalTurnaroundTime / n);
                printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
            }
            
            int main() {
                int n, timeQuantum = 4; // Time slice fixed at 4ms
            
                printf("Enter the number of processes: ");
                scanf("%d", &n);
            
                struct Process processes[n];
            
                // Input processes
                for (int i = 0; i < n; i++) {
                    processes[i].id = i + 1;
                    printf("Enter arrival time and burst time for Process P%d: ", processes[i].id);
                    scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
                    processes[i].remainingTime = processes[i].burstTime; // Initially, remaining time = burst time
                }
            
                calculateTimes(processes, n, timeQuantum);
                printResults(processes, n);
            
                return 0;
            }
            
            
            4)     FIFO  –page  replacement  algo  –( Consider the page reference string as
            7,1,0,2,0,3,0,4,2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1 with 3-page frames. Find   the total number of page faults)
            #include <stdio.h>
            #include <stdbool.h>
            
            int fifoPageReplacement(int reference[], int referenceLength, int numFrames) {
                int frames[numFrames];
                int pageFaults = 0;
                int front = 0; // Points to the oldest page in the frames
            
                // Initialize all frames as empty
                for (int i = 0; i < numFrames; i++) {
                    frames[i] = -1;
                }
            
                for (int i = 0; i < referenceLength; i++) {
                    int currentPage = reference[i];
                    bool found = false;
            
                    // Check if the page is already in the frames
                    for (int j = 0; j < numFrames; j++) {
                        if (frames[j] == currentPage) {
                            found = true;
                            break;
                        }
                    }
            
                    if (!found) {
                        // Replace the oldest page using FIFO policy
                        frames[front] = currentPage;
                        front = (front + 1) % numFrames; // Update the front pointer circularly
                        pageFaults++;
                    }
                }
            
                return pageFaults;
            }
            
            int main() {
                int reference[] = {7, 1, 0, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1};
                int referenceLength = sizeof(reference) / sizeof(reference[0]);
                int numFrames = 3;
            
                int totalPageFaults = fifoPageReplacement(reference, referenceLength, numFrames);
            
                printf("Total Page Faults: %d\n", totalPageFaults);
            
                return 0;
            }
            
            
            
            
            
            Q31. Implement  the  following  algorithms:
            1) FCFS- Disk scheduling algo (Consider the order of request for cylinder access of the disk is - (98, 183, 37, 122, 14, 124, 65, 67) and current position of Read/Write head is: 53. Find the total head movements to access the data on the cylinder)
            #include <stdio.h>
            #include <stdlib.h>
            
            void calculateFCFS(int requests[], int num_requests, int initial_position) {
                int total_distance = 0;
                int current_position = initial_position;
            
                printf("Processing Steps:\n");
            
                for (int i = 0; i < num_requests; i++) {
                    int distance = abs(current_position - requests[i]);
                    total_distance += distance;
                    printf("Move to %d: Distance from %d to %d = %d\n", requests[i], current_position, requests[i], distance);
                    current_position = requests[i];
                }
            
                printf("\nTotal Distance: %d\n", total_distance);
            }
            
            int main() {
                int initial_position = 53;
                int requests[] = {98, 183, 37, 122, 14, 124, 65, 67};
                int num_requests = sizeof(requests) / sizeof(requests[0]);
            
                calculateFCFS(requests, num_requests, initial_position);
            
                return 0;
            }
            
            
            
            
            
            
            
            2)     Best  Fit  –memory  placement  algo (process (P0 to P3).
            blockSize[]     = {100, 500, 200, 300, 600}
            processSize[] = {212, 417, 112, 426} Find which memory block is allocated to which process
            #include <stdio.h>
            
            void best_fit(int block_size[], int blocks, int process_size[], int processes);
            
            int main() {
                int block_size[] = {100, 500, 200, 300, 600};
                int process_size[] = {212, 417, 112, 426};
                int blocks = sizeof(block_size) / sizeof(block_size[0]);
                int processes = sizeof(process_size) / sizeof(process_size[0]);
            
                printf("--- Best Fit Allocation ---\n");
                best_fit(block_size, blocks, process_size, processes);
            
                return 0;
            }
            
            void best_fit(int block_size[], int blocks, int process_size[], int processes) {
                int allocation[processes];
            
                // Initialize allocation array
                for (int i = 0; i < processes; i++)
                    allocation[i] = -1;
            
                // Process each process
                for (int i = 0; i < processes; i++) {
                    int best_idx = -1;
            
                    // Find the best fit block for the current process
                    for (int j = 0; j < blocks; j++) {
                        if (block_size[j] >= process_size[i]) {
                            if (best_idx == -1 || block_size[j] < block_size[best_idx])
                                best_idx = j;
                        }
                    }
            
                    // If a suitable block was found
                    if (best_idx != -1) {
                        allocation[i] = best_idx;         // Allocate the block to the process
                        block_size[best_idx] -= process_size[i]; // Reduce the available size of the block
                    }
                }
            
                // Print allocation result
                printf("Process No.\tProcess Size\tBlock No.\n");
                for (int i = 0; i < processes; i++) {
                    printf("%d\t\t%d\t\t", i + 1, process_size[i]);
                    if (allocation[i] != -1)
                        printf("%d\n", allocation[i] + 1);
                    else
                        printf("Not Allocated\n");
                }
            }
            
            Q32. Implement  the  following  algorithms:
            1)     SSTF-  Disk  scheduling  algo  (Consider the order of request for cylinder access of the disk is - (98, 183, 37, 122, 14, 124, 65, 67) and current position of Read/Write head is: 53. Find the total head movements to access the data on the cylinder)
            #include <stdio.h>
            #include <stdlib.h>
            #include <stdbool.h>
            
            void calculateSSTF(int requests[], int num_requests, int initial_position) {
                int total_distance = 0;
                int current_position = initial_position;
                bool serviced[num_requests];
                for (int i = 0; i < num_requests; i++) {
                    serviced[i] = false;
                }
            
                printf("SSTF Processing Steps:\n");
            
                for (int i = 0; i < num_requests; i++) {
                    int closest_idx = -1;
                    int closest_distance = __INT_MAX__;
            
                    for (int j = 0; j < num_requests; j++) {
                        if (!serviced[j]) {
                            int distance = abs(current_position - requests[j]);
                            if (distance < closest_distance) {
                                closest_distance = distance;
                                closest_idx = j;
                            }
                        }
                    }
            
                    if (closest_idx != -1) {
                        printf("Move to %d: Distance from %d to %d = %d\n", requests[closest_idx], current_position, requests[closest_idx], closest_distance);
                        total_distance += closest_distance;
                        current_position = requests[closest_idx];
                        serviced[closest_idx] = true;
                    }
                }
            
                printf("\nTotal Distance: %d\n", total_distance);
            }
            
            int main() {
                // Hardcoded values from the problem statement
                int initial_position = 53;
                int requests[] = {98, 183, 37, 122, 14, 124, 65, 67};
                int num_requests = sizeof(requests) / sizeof(requests[0]);
            
                calculateSSTF(requests, num_requests, initial_position);
            
                return 0;
            }
            
            
            2)     First  Fit  –memory  placement  algo (process (P0 to P3).
            blockSize[]     = {100, 500, 200, 300, 600}
            processSize[] = {212, 417, 112, 426} Find which memory block is allocated to which process
            #include <stdio.h>
            
            void first_fit(int block_size[], int blocks, int process_size[], int processes);
            
            int main() {
                int block_size[] = {100, 500, 200, 300, 600};
                int process_size[] = {212, 417, 112, 426};
                int blocks = sizeof(block_size) / sizeof(block_size[0]);
                int processes = sizeof(process_size) / sizeof(process_size[0]);
            
                printf("--- First Fit Allocation ---\n");
                first_fit(block_size, blocks, process_size, processes);
            
                return 0;
            }
            
            void first_fit(int block_size[], int blocks, int process_size[], int processes) {
                int allocation[processes];
            
                // Initialize allocation array
                for (int i = 0; i < processes; i++)
                    allocation[i] = -1;
            
                // Allocate memory blocks to processes using First Fit
                for (int i = 0; i < processes; i++) {
                    for (int j = 0; j < blocks; j++) {
                        if (block_size[j] >= process_size[i]) {
                            allocation[i] = j;           // Assign block j to process i
                            block_size[j] -= process_size[i]; // Reduce the available size of block j
                            break; // Stop searching for this process
                        }
                    }
                }
            
                // Print allocation result
                printf("Process No.\tProcess Size\tBlock No.\n");
                for (int i = 0; i < processes; i++) {
                    printf("%d\t\t%d\t\t", i + 1, process_size[i]);
                    if (allocation[i] != -1)
                        printf("%d\n", allocation[i] + 1); // Add 1 to match block numbering
                    else
                        printf("Not Allocated\n");
                }
            }
            
            
            Q33. Implement  the  following  algorithms:
            3) SCAN- Disk scheduling algo (Consider the order of request for cylinder access of the disk is - (98, 183, 37, 122, 14, 124, 65, 67) and current position of Read/Write head is: 53. Find the total head movements to access the data on the cylinder)
            #include <stdio.h>
            #include <stdlib.h>
            
            #define MAX_CYLINDERS 200
            
            // Function to sort an array of integers in ascending order
            void sort_requests(int requests[], int n) {
                // Loop through the array
                for (int i = 0; i < n - 1; i++) {
                    // Loop through the array again, comparing each pair of adjacent elements
                    for (int j = 0; j < n - i - 1; j++) {
                        // If the current element is greater than the next element, swap them
                        if (requests[j] > requests[j + 1]) {
                            int temp = requests[j];
                            requests[j] = requests[j + 1];
                            requests[j + 1] = temp;
                        }
                    }
                }
            }
            
            void scan(int requests[], int n, int initial_position) {
                // Initialize total_movement to 0
                int total_movement = 0;
            
                // Sort the requests array
                sort_requests(requests, n);
            
                // Find the index of the first request that is greater than or equal to the initial position
                int current_index = 0;
                for (int i = 0; i < n; i++) {
                    if (requests[i] >= initial_position) {
                        current_index = i;
                        break;
                    }
                }
            
                printf("Request sequence:\n");
            
                    for (int i = current_index; i < n; i++) {
                        total_movement += abs(initial_position - requests[i]);
                        initial_position = requests[i];
                        printf("%d ", requests[i]);
                    }
                    total_movement += abs(initial_position - (MAX_CYLINDERS - 1));
                    initial_position = MAX_CYLINDERS - 1;
            
                    for (int i = current_index - 1; i >= 0; i--) {
                        total_movement += abs(initial_position - requests[i]);
                        initial_position = requests[i];
                        printf("%d ", requests[i]);
                    }
                    total_movement += abs(initial_position - 0);
                    initial_position = 0;
                printf("\n");
                printf("\nTotal Head Movement: %d\n", total_movement);
            }
            
            int main() {
                int requests[] = {98, 183, 37, 122, 14, 124, 65, 67};
                int n = sizeof(requests) / sizeof(requests[0]);
                int initial_position = 53;
              // Outward movement pre-set
            
                printf("Initial Position: %d\n", initial_position);
                printf("\n");
            
                scan(requests, n, initial_position);
            
                return 0;
            }
            
            
            
            
            4)     Worst  Fit  –memory  placement  algo (process (P0 to P3).
            blockSize[]     = {100, 500, 200, 300, 600}
            processSize[] = {212, 417, 112, 426} Find which memory block is allocated to which process
            #include <stdio.h>
            
            void worst_fit(int block_size[], int blocks, int process_size[], int processes);
            
            int main() {
                int block_size[] = {100, 500, 200, 300, 600};
                int process_size[] = {212, 417, 112, 426};
                int blocks = sizeof(block_size) / sizeof(block_size[0]);
                int processes = sizeof(process_size) / sizeof(process_size[0]);
            
                printf("--- Worst Fit Allocation ---\n");
                worst_fit(block_size, blocks, process_size, processes);
            
                return 0;
            }
            
            void worst_fit(int block_size[], int blocks, int process_size[], int processes) {
                int allocation[processes];
            
                // Initialize allocation array
                for (int i = 0; i < processes; i++)
                    allocation[i] = -1;
            
                // Allocate memory blocks to processes using Worst Fit
                for (int i = 0; i < processes; i++) {
                    int worst_idx = -1;
            
                    // Find the block with the largest size that can accommodate the process
                    for (int j = 0; j < blocks; j++) {
                        if (block_size[j] >= process_size[i]) {
                            if (worst_idx == -1 || block_size[j] > block_size[worst_idx])
                                worst_idx = j;
                        }
                    }
            
                    // If a suitable block was found
                    if (worst_idx != -1) {
                        allocation[i] = worst_idx;         // Allocate the block to the process
                        block_size[worst_idx] -= process_size[i]; // Reduce the block size
                    }
                }
            
                // Print allocation result
                printf("Process No.\tProcess Size\tBlock No.\n");
                for (int i = 0; i < processes; i++) {
                    printf("%d\t\t%d\t\t", i + 1, process_size[i]);
                    if (allocation[i] != -1)
                        printf("%d\n", allocation[i] + 1); // Add 1 to match block numbering
                    else
                        printf("Not Allocated\n");
                }
            }
            
            
            Q38. Following is the list of available blocks in the main memory and the process size for each process (P0 to P3).
            blockSize[]     = {100, 500, 200, 300, 600} processSize[] = {212, 417, 112, 426}
            Find which memory block is allocated to which process using following placement strategies:
            1)     Next fit
            #include <stdio.h>
            #include <stdbool.h>
            
            void next_fit(int block_size[], int blocks, int process_size[], int processes);
            
            int main() {
                int block_size[] = {100, 500, 200, 300, 600};
                int process_size[] = {212, 417, 112, 426};
                int blocks = sizeof(block_size) / sizeof(block_size[0]);
                int processes = sizeof(process_size) / sizeof(process_size[0]);
            
                printf("--- Next Fit Allocation ---\n");
                next_fit(block_size, blocks, process_size, processes);
            
                return 0;
            }
            
            void next_fit(int block_size[], int blocks, int process_size[], int processes) {
                int allocation[processes];
            
                // Initialize allocation array
                for (int i = 0; i < processes; i++)
                    allocation[i] = -1;
            
                int last_alloc = 0; // Start from the first block
            
                // Allocate memory blocks to processes using Next Fit
                for (int i = 0; i < processes; i++) {
                    bool allocated = false;
            
                    // Loop through the blocks starting from the last allocated position
                    for (int j = 0; j < blocks; j++) {
                        int index = (last_alloc + j) % blocks; // Circular traversal
                        if (block_size[index] >= process_size[i]) {
                            allocation[i] = index;             // Assign block to the process
                            block_size[index] -= process_size[i]; // Reduce block size
                            last_alloc = (index + 1) % blocks; // Update last allocated position
                            allocated = true;
                            break;
                        }
                    }
            
                    // If no suitable block is found, the process remains unallocated
                    if (!allocated) {
                        allocation[i] = -1;
                    }
                }
            
                // Print allocation result
                printf("Process No.\tProcess Size\tBlock No.\n");
                for (int i = 0; i < processes; i++) {
                    printf("%d\t\t%d\t\t", i + 1, process_size[i]);
                    if (allocation[i] != -1)
                        printf("%d\n", allocation[i] + 1); // Add 1 to match block numbering
                    else
                        printf("Not Allocated\n");
                }
            }
            
            
            
            2)     Worst fit
            #include <stdio.h>
            
            void worst_fit(int block_size[], int blocks, int process_size[], int processes);
            
            int main() {
                int block_size[] = {100, 500, 200, 300, 600};
                int process_size[] = {212, 417, 112, 426};
                int blocks = sizeof(block_size) / sizeof(block_size[0]);
                int processes = sizeof(process_size) / sizeof(process_size[0]);
            
                printf("--- Worst Fit Allocation ---\n");
                worst_fit(block_size, blocks, process_size, processes);
            
                return 0;
            }
            
            void worst_fit(int block_size[], int blocks, int process_size[], int processes) {
                int allocation[processes];
            
                // Initialize allocation array
                for (int i = 0; i < processes; i++)
                    allocation[i] = -1;
            
                // Allocate memory blocks to processes using Worst Fit
                for (int i = 0; i < processes; i++) {
                    int worst_idx = -1;
            
                    // Find the block with the largest size that can accommodate the process
                    for (int j = 0; j < blocks; j++) {
                        if (block_size[j] >= process_size[i]) {
                            if (worst_idx == -1 || block_size[j] > block_size[worst_idx])
                                worst_idx = j;
                        }
                    }
            
                    // If a suitable block was found
                    if (worst_idx != -1) {
                        allocation[i] = worst_idx;         // Allocate the block to the process
                        block_size[worst_idx] -= process_size[i]; // Reduce the block size
                    }
                }
            
                // Print allocation result
                printf("Process No.\tProcess Size\tBlock No.\n");
                for (int i = 0; i < processes; i++) {
                    printf("%d\t\t%d\t\t", i + 1, process_size[i]);
                    if (allocation[i] != -1)
                        printf("%d\n", allocation[i] + 1); // Add 1 to match block numbering
                    else
                        printf("Not Allocated\n");
                }
            }
            
            
            3)       Best fit
            #include <stdio.h>
            
            void best_fit(int block_size[], int blocks, int process_size[], int processes);
            
            int main() {
                int block_size[] = {100, 500, 200, 300, 600};
                int process_size[] = {212, 417, 112, 426};
                int blocks = sizeof(block_size) / sizeof(block_size[0]);
                int processes = sizeof(process_size) / sizeof(process_size[0]);
            
                printf("--- Best Fit Allocation ---\n");
                best_fit(block_size, blocks, process_size, processes);
            
                return 0;
            }
            
            void best_fit(int block_size[], int blocks, int process_size[], int processes) {
                int allocation[processes];
            
                // Initialize allocation array
                for (int i = 0; i < processes; i++)
                    allocation[i] = -1;
            
                // Process each process
                for (int i = 0; i < processes; i++) {
                    int best_idx = -1;
            
                    // Find the best fit block for the current process
                    for (int j = 0; j < blocks; j++) {
                        if (block_size[j] >= process_size[i]) {
                            if (best_idx == -1 || block_size[j] < block_size[best_idx])
                                best_idx = j;
                        }
                    }
            
                    // If a suitable block was found
                    if (best_idx != -1) {
                        allocation[i] = best_idx;         // Allocate the block to the process
                        block_size[best_idx] -= process_size[i]; // Reduce the available size of the block
                    }
                }
            
                // Print allocation result
                printf("Process No.\tProcess Size\tBlock No.\n");
                for (int i = 0; i < processes; i++) {
                    printf("%d\t\t%d\t\t", i + 1, process_size[i]);
                    if (allocation[i] != -1)
                        printf("%d\n", allocation[i] + 1);
                    else
                        printf("Not Allocated\n");
                }
            }
            
            
            Q39. Consider the page reference string as 7,1,0,2,0,3,0,4,2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1 with 3-page frames. Find the total number of page faults using following page replacement algorithms:
            1)     First In First Out
            #include <stdio.h>
            #include <stdbool.h>
            
            int fifoPageReplacement(int reference[], int referenceLength, int numFrames) {
                int frames[numFrames];
                int pageFaults = 0;
                int front = 0; // Points to the oldest page in the frames
            
                // Initialize all frames as empty
                for (int i = 0; i < numFrames; i++) {
                    frames[i] = -1;
                }
            
                for (int i = 0; i < referenceLength; i++) {
                    int currentPage = reference[i];
                    bool found = false;
            
                    // Check if the page is already in the frames
                    for (int j = 0; j < numFrames; j++) {
                        if (frames[j] == currentPage) {
                            found = true;
                            break;
                        }
                    }
            
                    if (!found) {
                        // Replace the oldest page using FIFO policy
                        frames[front] = currentPage;
                        front = (front + 1) % numFrames; // Update the front pointer circularly
                        pageFaults++;
                    }
                }
            
                return pageFaults;
            }
            
            int main() {
                int reference[] = {7, 1, 0, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1};
                int referenceLength = sizeof(reference) / sizeof(reference[0]);
                int numFrames = 3;
            
                int totalPageFaults = fifoPageReplacement(reference, referenceLength, numFrames);
            
                printf("Total Page Faults: %d\n", totalPageFaults);
            
                return 0;
            }
            
            
            2)     Optimal
            #include <stdio.h>
            
            int findOptimalPage(int reference[], int pages[], int currentIndex, int numFrames, int referenceLength) {
                int farthest = currentIndex, pageToReplace = -1;
            
                for (int i = 0; i < numFrames; i++) {
                    int j;
                    for (j = currentIndex; j < referenceLength; j++) {
                        if (pages[i] == reference[j]) {
                            if (j > farthest) {
                                farthest = j;
                                pageToReplace = i;
                            }
                            break;
                        }
                    }
                    // If page is not referenced in the future
                    if (j == referenceLength) {
                        return i;
                    }
                }
            
                // If all pages are referenced, replace the farthest one
                return (pageToReplace == -1) ? 0 : pageToReplace;
            }
            
            int optimalPageReplacement(int reference[], int referenceLength, int numFrames) {
                int pages[numFrames];
                int pageFaults = 0;
            
                for (int i = 0; i < numFrames; i++) {
                    pages[i] = -1; // Initialize pages with -1 (empty)
                }
            
                for (int i = 0; i < referenceLength; i++) {
                    int found = 0;
            
                    // Check if the current page is already in frames
                    for (int j = 0; j < numFrames; j++) {
                        if (pages[j] == reference[i]) {
                            found = 1;
                            break;
                        }
                    }
            
                    if (!found) {
                        // Find the page to replace
                        if (i < numFrames) {
                            pages[i] = reference[i];
                        } else {
                            int replaceIndex = findOptimalPage(reference, pages, i + 1, numFrames, referenceLength);
                            pages[replaceIndex] = reference[i];
                        }
                        pageFaults++;
                    }
                }
            
                return pageFaults;
            }
            
            int main() {
                int reference[] = {7, 1, 0, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1};
                int referenceLength = sizeof(reference) / sizeof(reference[0]);
                int numFrames = 3;
            
                int totalPageFaults = optimalPageReplacement(reference, referenceLength, numFrames);
            
                printf("Total Page Faults: %d\n", totalPageFaults);
            
                return 0;
            }
            
            
            Q40. Write a program to implement following CPU scheduling algorithms:
            1)     SJF
            Non-pre
            #include <stdio.h>
            
            struct Process {
                int id;
                int arrivalTime;
                int burstTime;
                int completionTime;
                int turnaroundTime;
                int waitingTime;
            };
            
            void calculateTimes(struct Process processes[], int n) {
                int currentTime = 0;
                int completed = 0;
                int minIndex;
            
                while (completed < n) {
                    minIndex = -1;
                   
                   
                    for (int i = 0; i < n; i++) {
                        if (processes[i].arrivalTime <= currentTime && processes[i].completionTime == 0) {
                            if (minIndex == -1 || processes[i].burstTime < processes[minIndex].burstTime) {
                                minIndex = i;
                            }
                        }
                    }
            
                    if (minIndex != -1) {
                        currentTime += processes[minIndex].burstTime;
                        processes[minIndex].completionTime = currentTime;
                        processes[minIndex].turnaroundTime = processes[minIndex].completionTime - processes[minIndex].arrivalTime;
                        processes[minIndex].waitingTime = processes[minIndex].turnaroundTime - processes[minIndex].burstTime;
                        completed++;
                    } else {
                        currentTime++;
                    }
                }
            }
            
            void printGanttChart(struct Process processes[], int n) {
                printf("\nGantt Chart:\n");
                for (int i = 0; i < n; i++) {
                    if (processes[i].completionTime != 0) {
                        printf("P%d ", processes[i].id);
                    }
                }
                printf("\n");
            
                printf("0 ");
                for (int i = 0; i < n; i++) {
                    if (processes[i].completionTime != 0) {
                        printf("%d ", processes[i].completionTime);
                    }
                }
                printf("\n");
            }
            
            int main() {
                int n;
            
                printf("Enter the number of processes: ");
                scanf("%d", &n);
            
                struct Process processes[n];
            
                for (int i = 0; i < n; i++) {
                    processes[i].id = i + 1;
                    printf("Enter arrival time and burst time for Process P%d: ", processes[i].id);
                    scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
                    processes[i].completionTime = 0;
                }
            
                calculateTimes(processes, n);
            
                printf("\nProcess ID\tArrival Time\tBurst Time\tCompletion Time\tTurnaround Time\tWaiting Time\n");
                for (int i = 0; i < n; i++) {
                    printf("P%-10d\t%-12d\t%-10d\t%-15d\t%-15d\t%-10d\n", processes[i].id,
                           processes[i].arrivalTime,
                           processes[i].burstTime,
                           processes[i].completionTime,
                           processes[i].turnaroundTime,
                           processes[i].waitingTime);
                }
            
                float totalTurnaroundTime = 0, totalWaitingTime = 0;
                for (int i = 0; i < n; i++) {
                    totalTurnaroundTime += processes[i].turnaroundTime;
                    totalWaitingTime += processes[i].waitingTime;
                }
            
                printf("\nAverage Turnaround Time: %.2f\n", totalTurnaroundTime / n);
                printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
            
                printGanttChart(processes, n);
            
                return 0;
            }
            
            Pre
            #include <stdio.h>
            
            struct Process {
                int id;
                int arrivalTime;
                int burstTime;
                int remainingTime;
                int completionTime;
                int turnaroundTime;
                int waitingTime;
            };
            
            void calculateTimes(struct Process processes[], int n) {
                int currentTime = 0;
                int completed = 0;
            
                while (completed < n) {
                    int minIndex = -1;
                    int minRemainingTime = 9999;
            
                    for (int i = 0; i < n; i++) {
                        if (processes[i].arrivalTime <= currentTime && processes[i].remainingTime > 0) {
                            if (processes[i].remainingTime < minRemainingTime) {
                                minRemainingTime = processes[i].remainingTime;
                                minIndex = i;
                            }
                        }
                    }
            
                    if (minIndex != -1) {
                        processes[minIndex].remainingTime--;
                        currentTime++;
            
                        if (processes[minIndex].remainingTime == 0) {
                            processes[minIndex].completionTime = currentTime;
                            processes[minIndex].turnaroundTime = processes[minIndex].completionTime - processes[minIndex].arrivalTime;
                            processes[minIndex].waitingTime = processes[minIndex].turnaroundTime - processes[minIndex].burstTime;
                            completed++;
                        }
                    } else {
                        currentTime++;
                    }
                }
            }
            
            void printGanttChart(struct Process processes[], int n) {
                printf("\nGantt Chart:\n");
                for (int i = 0; i < n; i++) {
                    if (processes[i].completionTime != 0) {
                        printf("P%d ", processes[i].id);
                    }
                }
                printf("\n");
            
                printf("0 ");
                for (int i = 0; i < n; i++) {
                    if (processes[i].completionTime != 0) {
                        printf("%d ", processes[i].completionTime);
                    }
                }
                printf("\n");
            }
            
            int main() {
                int n;
            
                printf("Enter the number of processes: ");
                scanf("%d", &n);
            
                struct Process processes[n];
            
                for (int i = 0; i < n; i++) {
                    processes[i].id = i + 1;
                    printf("Enter arrival time and burst time for Process P%d: ", processes[i].id);
                    scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
                    processes[i].remainingTime = processes[i].burstTime;
                }
            
                calculateTimes(processes, n);
            
                printf("\nProcess ID\tArrival Time\tBurst Time\tCompletion Time\tTurnaround Time\tWaiting Time\n");
                for (int i = 0; i < n; i++) {
                    printf("P%-10d\t%-12d\t%-10d\t%-15d\t%-15d\t%-10d\n", processes[i].id,
                           processes[i].arrivalTime,
                           processes[i].burstTime,
                           processes[i].completionTime,
                           processes[i].turnaroundTime,
                           processes[i].waitingTime);
                }
            
                float totalTurnaroundTime = 0, totalWaitingTime = 0;
                for (int i = 0; i < n; i++) {
                    totalTurnaroundTime += processes[i].turnaroundTime;
                    totalWaitingTime += processes[i].waitingTime;
                }
            
                printf("\nAverage Turnaround Time: %.2f\n", totalTurnaroundTime / n);
                printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
            
                printGanttChart(processes, n);
            
                return 0;
            }
            
            
            2)     SRTF
            
            BASIC CODE : 
            LINUX COMMANDS -
            Here’s a step-by-step guide to execute each of the Linux commands in your list:
            ________________________________________
            1. Change your password
            passwd
            
            ________________________________________
            2. Display the system’s date
            date
            
            ________________________________________
            3. Count the number of lines in the /etc/passwd file
            wc -l /etc/passwd
            
            ________________________________________
            4. Find out who else is on the system
            who
            
            ________________________________________
            5. Redirect the output of the man pages for the date command to a file named mydate
            man date > mydate
            
            ________________________________________
            6. Create a subdirectory called mydir
            mkdir mydir
            
            ________________________________________
            7. Move the file mydate into the new subdirectory
            mv mydate mydir/
            
            ________________________________________
            8. Go to the subdirectory mydir and copy the file mydate to a new file called ourdate
            cd mydir
            cp mydate ourdate
            
            ________________________________________
            9. List the contents of mydir
            ls
            
            ________________________________________
            10. Do a long listing on the file ourdate and note the permissions
            ls -l ourdate
            
            ________________________________________
            11. Display the name of the current directory starting from the root
            pwd
            
            ________________________________________
            12. Move the files in the directory mydir back to your home directory
            mv * ~
            
            ________________________________________
            13. Display the first 5 lines of mydate
            head -n 5 mydate
            
            ________________________________________
            14. Display the last 8 lines of mydate
            tail -n 8 mydate
            
            ________________________________________
            15. Remove the directory mydir
            cd ..
            rmdir mydir
            
            ________________________________________
            16. Redirect the output of the long listing of files to a file named list
            ls -l > list
            
            ________________________________________
            17. Create files capitals1, capitals2, capitals3, and concatenate them into capitals
            echo -e "Delhi\nMumbai\nKolkata\nChennai\nBangalore" > capitals1
            echo -e "Hyderabad\nJaipur\nLucknow\nPatna\nRaipur" > capitals2
            echo -e "Bhopal\nShimla\nDehradun\nGangtok\nAizawl" > capitals3
            cat capitals1 capitals2 capitals3 > capitals
            
            ________________________________________
            18. Concatenate the file capitals2 at the end of capitals
            cat capitals2 >> capitals
            
            ________________________________________
            19. Give read and write permissions to all users for the file capitals
            chmod 666 capitals
            
            ________________________________________
            20. Give read permissions only to the owner of the file capitals
            chmod 400 capitals
            
            ●	Open the file and try editing:
            nano capitals
            
            ●	Result: You will not be able to save changes because write permission is not granted.
            ________________________________________
            21. Create an alias for concatenating files into capitals
            alias makecapitals='cat capitals1 capitals2 capitals3 > capitals'
            makecapitals
            
            ________________________________________
            22. Find out the number of times the string "the" appears in mydate
            grep -o "the" mydate | wc -l
            
            ________________________________________
            23. Find out the line numbers on which the string "date" exists in mydate
            grep -n "date" mydate
            
            ________________________________________
            24. Print all lines of mydate except those that have the letter "i" in them
            grep -v "i" mydate
            
            ________________________________________
            25. List the words of 4 letters from the file mydate
            grep -oE '\b\w{4}\b' mydate
            
            ________________________________________
            26. List states and capitals using the paste command
            echo -e "Assam\nMeghalaya\nManipur\nMizoram\nTripura" > mystates
            echo -e "Dispur\nShillong\nImphal\nAizawl\nAgartala" > mycapitals
            paste mystates mycapitals
            
            ________________________________________
            27. Print the 1st and 3rd columns of /etc/passwd
            cut -d ':' -f 1,3 /etc/passwd
            
            ________________________________________
            28. Count the number of people logged in and save users in a file
            who | tee logged_users | wc -l
            
            ________________________________________
            29. Convert the contents of mystates into uppercase
            tr '[:lower:]' '[:upper:]' < mystates
            
            ________________________________________
            30. Display common values between two files
            echo -e "Delhi\nMumbai\nKolkata" > file1
            echo -e "Kolkata\nChennai\nDelhi" > file2
            comm -12 <(sort file1) <(sort file2)
            
            Here’s how you can handle each of the tasks you mentioned:
            ________________________________________
            1. Create Student Record Text File as “Student1” for Given Input Student Details
            Assuming the details are in the format:
            RollNo Name Year Division Email Gender PRN
            
            Command:
            echo -e "1234 John Btech A john@example.com Male 4567\n5678 Alice TY B alice@example.com Female 7890\n9012 Bob SY C bob@example.com Male 1234" > Student1
            
            ________________________________________
            2. Find Out BTech Student from "Student1" File and Save Content into "Btech" File
            Command:
            grep "Btech" Student1 > Btech
            
            ________________________________________
            3. Find Out TY Student from "Student1" File and Save Content into "TY" File
            Command:
            grep "TY" Student1 > TY
            
            ________________________________________
            4. Find Out SY Student from "Student1" File and Save Content into "SY" File
            Command:
            grep "SY" Student1 > SY
            
            ________________________________________
            5. Combine SY and TY Students from "Student1" File and Save Content into "SYTY" File
            Command:
            cat SY TY > SYTY
            
            ________________________________________
            6. Sort the File Based on Roll No. and Save Content into "Student2" File
            Command:
            sort -k1 Student1 > Student2
            
            ________________________________________
            7. Compare "Student1" File with "Btech" File and Save Content into "Student2" File
            Command:
            comm -3 Student1 Btech > Student2
            
            ________________________________________
            8. Find Out PRN NO, Student Name, Year and Division Field Data from "Student1" File and Save into "Student3" File
            Command:
            cut -d ' ' -f 6,2,3,4 Student1 > Student3
            
            ________________________________________
            9. (Repeat of Task 8) Find Out PRN NO, Student Name, Year and Division Field Data from "Student1" File and Save into "Student3" File
            (Already answered in Task 8)
            ________________________________________
            10. Find Out Roll No., Email Id and Gender Field Data from "Student1" File and Save into "Student4" File
            Command:
            cut -d ' ' -f 1,5,6 Student1 > Student4
            
            ________________________________________
            11. Combine "Student3" and "Student4" File and Save Content into "Student5" File
            Command:
            cat Student3 Student4 > Student5
            
            ________________________________________
            12. Convert "Student1" Content into Uppercase Letter and Save into "Student6" File
            Command:
            tr 'a-z' 'A-Z' < Student1 > Student6
            
            ________________________________________
            13. Compare "Student1" and "BTech" File and Save Content into "Student7" File
            Command:
            comm -3 Student1 Btech > Student7
            
            ________________________________________
            14. Find Out Common Between "Student1" and "Btech" File and Save Content into "Student9" File
            Command:
            comm -12 Student1 Btech > Student9
            
            ________________________________________
            15. Remove User and Group of "SY" File, Read and Write Permission File. Assign Read, Write, Execute Permission to User and Others of "SY" File
            Remove user and group (if needed):
            chown --no-dereference : SY
            
            Assign Read, Write, Execute Permissions to User and Others:
            chmod 777 SY
            
            ________________________________________
            16. Display Count of Male Students from "Student1" File
            Command:
            grep -c "Male" Student1
            
            ________________________________________
            17. Find Out Name of Student Field Data from "Student1" File and Redirect Output to Count
            Command:
            cut -d ' ' -f 2 Student1 > count
            
            ________________________________________
            18. Number of Students in "Student1" File
            Command:
            wc -l Student1
            
            ________________________________________
            19. Find Out File and Directory in Current Path and Trap This Output in Userfile as “ufile” and Also Display Count of Number of Directories and Files in Current Path (Use Only One Command)
            Command:
            ls -l | tee ufile | wc -l
            
            This will list all files and directories, save the output to ufile, and then count the total number of files and directories.
            ________________________________________
            These are the commands to perform each of the required tasks. Let me know if you need further clarification on any command!
            SHELL SCRIPT:
            1. Check if number entered by user is greater than 10.
            bash
            Copy code
            #!/bin/bash
            read -p "Enter a number: " num
            if [ $num -gt 10 ]; then
              echo "The number is greater than 10."
            else
              echo "The number is not greater than 10."
            fi
            
            ________________________________________
            2. Check if a file exists, if not create it.
            bash
            Copy code
            #!/bin/bash
            read -p "Enter file name: " file
            if [ ! -f "$file" ]; then
              touch "$file"
              echo "File '$file' created."
            else
              echo "File '$file' already exists."
            fi
            
            ________________________________________
            3. Check if first argument is a directory; if not, create second argument as a directory.
            bash
            Copy code
            #!/bin/bash
            if [ -d "$1" ]; then
              echo "The first argument is a directory."
            else
              mkdir -p "$2"
              echo "Directory '$2' created."
            fi
            
            ________________________________________
            4. Check if arguments passed are greater than 5.
            bash
            Copy code
            #!/bin/bash
            if [ $# -gt 5 ]; then
              echo "Too many arguments."
            else
              echo "Argument count is fine."
            fi
            
            ________________________________________
            5. Check if command-line argument is a file or directory.
            bash
            Copy code
            #!/bin/bash
            if [ -f "$1" ]; then
              echo "$1 is a file."
            elif [ -d "$1" ]; then
              echo "$1 is a directory."
            else
              echo "$1 does not exist."
            fi
            
            ________________________________________
            6. Check if entered month is August or October.
            bash
            Copy code
            #!/bin/bash
            read -p "Enter a month name: " month
            if [[ "$month" == "August" || "$month" == "October" ]]; then
              echo "The month is $month."
            else
              echo "The month is not August or October."
            fi
            
            ________________________________________
            7. Check whether file or directory exists.
            bash
            Copy code
            #!/bin/bash
            read -p "Enter a file or directory name: " name
            if [ -e "$name" ]; then
              echo "$name exists."
            else
              echo "$name does not exist."
            fi
            
            ________________________________________
            8. Check if a file exists and is readable.
            bash
            Copy code
            #!/bin/bash
            read -p "Enter file name: " file
            if [ -f "$file" ] && [ -r "$file" ]; then
              echo "File '$file' exists and is readable."
            else
              echo "File '$file' does not exist or is not readable."
            fi
            
            ________________________________________
            9. Check if the present month is August.
            bash
            Copy code
            #!/bin/bash
            current_month=$(date +%B)
            if [ "$current_month" == "August" ]; then
              echo "The current month is August."
            else
              echo "The current month is not August."
            fi
            
            ________________________________________
            10. Check if the current user is root or a regular user.
            bash
            Copy code
            #!/bin/bash
            if [ $(id -u) -eq 0 ]; then
              echo "You are root."
            else
              echo "You are a regular user."
            fi
            
            ________________________________________
            11. Check command-line arguments; print or list them.
            bash
            Copy code
            #!/bin/bash
            if [ $# -gt 3 ]; then
              echo "Arguments passed: $@"
            else
              echo "Type more next time."
            fi
            1. Execute ls, date, pwd repetitively
            bash
            Copy code
            #!/bin/bash
            while true; do
              ls
              date
              pwd
              sleep 5 # Wait for 5 seconds before repeating
            done
            
            ________________________________________
            2. Assign value to a variable and display it with and without $
            bash
            Copy code
            #!/bin/bash
            name="Shell Scripting"
            echo "With \$: $name"
            echo "Without \$: name"
            
            ________________________________________
            3. Show variables are untyped
            bash
            Copy code
            #!/bin/bash
            var=10
            echo "Integer: $var"
            var="Hello"
            echo "String: $var"
            var=5.5
            echo "Float: $var"
            
            ________________________________________
            4. Accept numbers from the user (Keyboard input)
            bash
            Copy code
            #!/bin/bash
            read -p "Enter a number: " num
            echo "You entered: $num"
            
            ________________________________________
            5. Accept numbers from command-line arguments
            bash
            Copy code
            #!/bin/bash
            echo "First number: $1"
            echo "Second number: $2"
            
            ________________________________________
            6. Show contents of environmental variables SHELL, PATH, HOME
            bash
            Copy code
            #!/bin/bash
            echo "SHELL: $SHELL"
            echo "PATH: $PATH"
            echo "HOME: $HOME"
            
            ________________________________________
            7. Create two files with names provided by the user
            bash
            Copy code
            #!/bin/bash
            read -p "Enter first file name: " file1
            read -p "Enter second file name: " file2
            touch "$file1" "$file2"
            echo "Files $file1 and $file2 created."
            
            ________________________________________
            8. Create two directories with names from command-line arguments
            bash
            Copy code
            #!/bin/bash
            mkdir "$1" "$2"
            echo "Directories $1 and $2 created."
            
            ________________________________________
            9. Copy content from one file to another (file names via command-line arguments)
            bash
            Copy code
            #!/bin/bash
            cp "$1" "$2"
            echo "Content copied from $1 to $2."
            
            ________________________________________
            10. Rename a file (old and new names via command-line arguments)
            bash
            Copy code
            #!/bin/bash
            mv "$1" "$2"
            echo "File $1 renamed to $2."
            
            ________________________________________
            11. Perform arithmetic operations on integer data
            bash
            Copy code
            #!/bin/bash
            read -p "Enter first number: " num1
            read -p "Enter second number: " num2
            echo "Addition: $((num1 + num2))"
            echo "Subtraction: $((num1 - num2))"
            echo "Multiplication: $((num1 * num2))"
            echo "Division: $((num1 / num2))"
            
            ________________________________________
            12. Perform arithmetic operations on float data
            bash
            Copy code
            #!/bin/bash
            read -p "Enter first number: " num1
            read -p "Enter second number: " num2
            echo "Addition: $(echo "$num1 + $num2" | bc)"
            echo "Subtraction: $(echo "$num1 - $num2" | bc)"
            echo "Multiplication: $(echo "$num1 * $num2" | bc)"
            echo "Division: $(echo "scale=2; $num1 / $num2" | bc)"
            
            
            
            Phase 1
            #include <stdio.h>
            #include <stdlib.h>
            #include <string.h>
            
            char M[100][4];
            char R[4];
            char IR[4];
            int IC = 0, SI = 0;
            char buffer[40];
            int C = 0;  
            
            FILE *input, *output;
            
            void clearBuffer() {
                for (int i = 0; i < 40; i++) {
                    buffer[i] = '\0';
                }
            }
            
            int GETLOCATION() {
                int WordNumber = ((IR[2] - '0') * 10) + (IR[3] - '0');
                return WordNumber;
            }
            
            void INIT() {
                for (int i = 0; i < 100; i++) {
                    for (int j = 0; j < 4; j++) {
                        M[i][j] = ' ';
                    }
                }
            
                for (int i = 0; i < 4; i++) {
                    R[i] = ' ';
                    IR[i] = ' ';
                }
            
                C = 0;  
                IC = 0;
            }
            
            void READ() {
                int loc = GETLOCATION();
                int k = 0;
                clearBuffer();
            
                fgets(buffer, 40, input);
            
                while (k < 99 && buffer[k] != '\0') {
                    for (int j = 0; j < 4; j++) {
                        if (buffer[k] == '\n') {
                            k++;
                            continue;
                        }
                        M[loc][j] = buffer[k];
                        k++;
                    }
                    loc++;
                }
            }
            
            void WRITE() {
                output = fopen("output.txt", "a");
                if (output == NULL) {
                    printf("Could not open output file.\n");
                    return;
                }
            
                int loc = GETLOCATION();
                for (int i = loc; i < loc + 10; i++) {
                    for (int k = 0; k < 4; k++) {
                        if (M[i][k] != '\0') {
                            fprintf(output, "%c", M[i][k]);
                        }
                    }
                }
                fprintf(output, "\n");
                fclose(output);
            }
            
            void TERMINATE() {
                output = fopen("output.txt", "a");
                if (output == NULL) {
                    printf("Could not open output file.\n");
                    return;
                }
                fprintf(output, "\n\n");
                fclose(output);
            }
            
            void MOS() {
                switch (SI) {
                    case 1:
                        READ();
                        break;
                    case 2:
                        WRITE();
                        break;
                    case 3:
                        TERMINATE();
                        break;
                    default:
                        break;
                }
                SI = 0;
            }
            
            void EXECUTION() {
                while (1) {
                    for (int i = 0; i < 4; i++) {
                        IR[i] = M[IC][i];
                    }
                    IC++;
            
                    if (IR[0] == 'G') {
                        SI = 1;
                        MOS();
                    } else if (IR[0] == 'P') {
                        SI = 2;
                        MOS();
                    } else if (IR[0] == 'H') {
                        SI = 3;
                        MOS();
                        break;
                    } else if (IR[0] == 'L') {
                        int loc = GETLOCATION();
                        for (int i = 0; i < 4; i++) {
                            R[i] = M[loc][i];
                        }
                    } else if (IR[0] == 'S') {
                        int loc = GETLOCATION();
                        for (int i = 0; i < 4; i++) {
                            M[loc][i] = R[i];
                        }
                    } else if (IR[0] == 'C') {
                        int loc = GETLOCATION();
                        C = 1;
                        for (int i = 0; i < 4; i++) {
                            if (M[loc][i] != R[i]) {
                                C = 0;  
                                break;
                            }
                        }
                    } else if (IR[0] == 'B') {
                        if (C) {
                            int loc = GETLOCATION();
                            IC = loc;
                        }
                    }
                }
            }
            
            void STARTEXECUTION() {
                IC = 0;
                EXECUTION();
            }
            
            void LOAD() {
                if (input == NULL) {
                    printf("Could not open input file.\n");
                    return;
                }
            
                int jobStarted = 0;  
            
                while (fgets(buffer, 40, input) != NULL) {
                    if (strncmp(buffer, "$AMJ", 4) == 0) {
                        if (jobStarted) {
                            TERMINATE();
                        }
                        INIT();
                        jobStarted = 1;  
                    } else if (strncmp(buffer, "$DTA", 4) == 0) {
                        if (!jobStarted) {
                            printf("Error: $DTA found before $AMJ.\n");
                            return;
                        }
                        clearBuffer();
                        STARTEXECUTION();
                    } else if (strncmp(buffer, "$END", 4) == 0) {
                        if (!jobStarted) {
                            printf("Error: $END found before $AMJ.\n");
                            return;
                        }
                        for (int i = 0; i < 100; i++) {
                            printf("M[%d]:%c%c%c%c\n", i, M[i][0], M[i][1], M[i][2], M[i][3]);
                        }
                        TERMINATE();
                        jobStarted = 0;
                    } else {
                        int i = IC;
                        int j = 0;
                        while (j < 99 && buffer[j] != '\0' && buffer[j] != '\n') {
                            for (int k = 0; k < 4; k++) {
                                if (buffer[j] == 'H' && buffer[j] != '\n') {
                                    M[i][k] = 'H';
                                    j++;
                                    break;
                                }
                                M[i][k] = buffer[j++];
                            }
                            i++;
                        }
                        IC = i;
                    }
                    clearBuffer();
                }
            
                if (jobStarted) {
                    TERMINATE();
                }
            }
            
            int main() {
                input = fopen("input.txt", "r");
                output = fopen("output.txt", "w");
            
                if (input == NULL) {
                    printf("Can't open input file\n");
                    return 1;
                } else {
                    printf("Input file opened successfully\n");
                }
            
                LOAD();
            
                fclose(input);
                fclose(output);
            
            return 0;
            }
            
            
            Phase2
            #include<stdio.h>
            #include<stdlib.h>
            #include<string.h>
            #include<time.h>
            
            void EXECUTE();
            void INIT();
            void LOADINSTRUCTIONSETINTOMEMORY();
            void CHECKERRORS();
            void READ_FILE();
            void LOADINSTRUCTIONTOBUFFER();
            void PRINTMEMORY();
            void PRINTBUFFER();
            
            int GETRANDOM(int min, int max) {
                int rd_num = rand() % (max - min + 1) + min;
                return rd_num;
            }
            
            char M[4][300], IR[4], R[4], BUFF[4][10], ttl[4], tll[4];
            int m, IC, SI, PCI=0, DCI=0, ptr, bp=0, c=1, temp=0, x=0, TTL=0, TLL=0, PI, TTC, PTR, errors, LLC;
            int PTE, RA, ICR, ptl, toggle[300], v, pe;
            FILE *input, *output;
            char line[256], job[4], line2[256];
            int randAd[30] = {14, 3, 25, 7, 0, 27, 9, 12, 21, 5, 17, 10, 28, 1, 23, 18, 19, 26, 2, 4, 15, 6, 13, 24, 8, 29, 22, 16, 11, 20};
            
            //This function takes an integer va as an argument and returns an integer ra
            int MAP(int va){
                //Initialize ra to 0
                int ra=0;
                //Loop through the array M from index PTR to PTR+10
                for(int i=PTR; i<PTR+10; i++){
                    //Check if the value at index i in the first two rows of M is equal to va
                    if((M[0][i]-'0')*10 + (M[1][i] - '0') == va){
                        //If it is, set ra to the value at index i in the last two rows of M
                        ra = (M[2][i] - '0') *10 + (M[3][i] - '0');
                        //Return ra
                        return ra;
                    }
                }
                //If no match is found, return ra
                return ra;
            }
            
            //This function prints the memory of the program
            void PRINTMEMORY(){
                //Loop through the memory
                for(int i=0; i<300; i++){
                    //Print the index
                    printf("%d ", i);
                    //Loop through the memory at the index
                    for(int j=0; j<4; j++){
                        //Print the value at the index
                        printf("%c ", M[j][i]);
                    }
                    //Print a new line
                    printf("\n");
                }
            }
            
            void PRINTBUFFER(){
                for(int i=0; i<10; i++){
                    printf("%d ", i);
                    for(int j=0; j<4; j++){
                        printf("%c ", BUFF[j][i]);
                    }
                    printf("\n");
                }
            }
            
            //This function loads an instruction into the buffer
            void LOADINSTRUCTIONTOBUFFER(char*s, int x, int y){
                //Initialize the array pointer to 0
                int ap=0;
                //Loop through the string starting at 40*(x-y) and incrementing by 4
                for(int i=40*(x-y); i<40+(40*(x-y)); i+=4){
                    //If the character is a newline, break the loop
                    if(s[i] == '\n') break;
                    //Load the character into the buffer
                    BUFF[0][ap] = s[i];
                    //If the character is 'H', decrement the index by 3
                    if(s[i] == 'H'){
                        i-=3;
                    //Otherwise, load the next 3 characters into the buffer
                    }else{
                        BUFF[1][ap] = s[i+1];
                        BUFF[2][ap] = s[i+2];
                        BUFF[3][ap] = s[i+3];
                    }
                    //Increment the array pointer
                    ap++;
                }
                //Load the instruction set into memory
                LOADINSTRUCTIONSETINTOMEMORY();
                //If y is greater than 0, recursively call the function with y-1
                if(y > 0){
                    LOADINSTRUCTIONTOBUFFER(s, x, y-1);
                }
            }
            
            // Initialize the memory, registers, and other variables
            void INIT(){
                // Loop through the memory and set all values to '-'
                for(int i=0; i<4; i++){
                    for(int j=0; j<300; j++){
                        M[i][j] = '-';
                        toggle[j] = 0;
                    }
                }
                // Loop through the registers and set all values to '-'
                for(int i=0; i<4; i++){
                    IR[i] = '-';
                    R[i] = '-';
                    for(int j=0; j<10; j++){
                        BUFF[j][i] = '-';
                    }
                }
                // Initialize the other variables
                m=0, SI=0, IC=0, TTL=0, TLL=0, TTC=0, PI=0;
                LLC=0;
                ptr=1;
                PTR = randAd[0] * 10;
                errors = 0;
                ICR=0;
                ptl = 0;
                pe=0;
            }
            
            void EXECUTE() {
                // Check for errors
                CHECKERRORS();
                // If there are errors, return
                if (errors == 1) return;
                // Copy the instruction register to the IR
                for (int i = 0; i < 4; i++) {
                    IR[i] = M[i][m];
                }
            
                int IC, t, lf = 0, e = 0;
            
                // Switch statement to execute the instruction
                switch (IR[0]) {
                    case 'G':
                        // If the second character is not 'D', set PI to 1
                        if (IR[1] != 'D') {
                            PI = 1;
                            break;
                        }
                        // Increment the instruction counter and total time counter
                        ICR++;
                        TTC += 2;
                        // Get the IC from the IR
                        IC = (IR[2] - '0') * 10 + (IR[3] - '0');
                        // Toggle the IC
                        toggle[IC] = 1;
                        // Store the IC in the memory
                        M[0][PTR + ptl] = IC / 10 + '0';
                        M[1][PTR + ptl] = IC % 10 + '0';
                        // Get a random address
                        t = randAd[ptr] * 10;
                        // Store the random address in the memory
                        M[2][PTR + ptl] = randAd[ptr] / 10 + '0';
                        M[3][PTR + ptl] = randAd[ptr] % 10 + '0';
                        // Increment the pointers
                        ptr++;
                        ptl++;
                        // If the IC is out of range, set PI to 2
                        if (IC < 0 || IC > 99) {
                            PI = 2;
                            break;
                        }
            
                        // If the buffer is empty, set PI to 4
                        if (BUFF[0][bp] == '-') {
                            PI = 4;
                            break;
                        }
            
                        // Read the buffer into the memory
                        while (lf == 0) {
                            for (int i = 0; i < 4; i++) {
                                if (BUFF[i][bp] != '\n') {
                                    M[i][t + e] = BUFF[i][bp];
                                } else {
                                    lf = 1;
                                }
                            }
                            bp++;
                            e++;
                        }
                        break;
            
                    case 'P':
                        // If the second character is not 'D', set PI to 1
                        if (IR[1] != 'D') {
                            PI = 1;
                            break;
                        }
                        // Increment the instruction counter and total time counter
                        ICR++;
                        TTC++;
                        // Get the IC from the IR
                        IC = (IR[2] - '0') * 10 + (IR[3] - '0');
                        // Get the address from the memory map
                        t = MAP(IC) * 10;
                        // If the IC is not toggled, set PI to 3
                        if (toggle[IC] == 0) {
                            PI = 3;
                            break;
                        }
                        // If the IC is out of range, set PI to 2
                        if (IC < 0 || IC > 99) {
                            PI = 2;
                            break;
                        }
            
                        // Open the output file
                        output = fopen("output.txt", "a");
                        // Write the memory to the output file
                        for (int j = 0; j < 10; j++) {
                            for (int i = 0; i < 4; i++) {
                                if (M[i][t + j] == '\n' || M[i][t + j] == '-') {
                                    break;
                                }
                                fprintf(output, "%c", M[i][t + j]);
                            }
                        }
                        // Close the output file
                        fprintf(output, "\n");
                        fclose(output);
                        break;
            
                    case 'L':
                        // If the second character is not 'R', set PI to 1
                        if (IR[1] != 'R') {
                            PI = 1;
                            break;
                        }
                        // Increment the instruction counter and total time counter
                        ICR++;
                        TTC++;
                        // Get the IC from the IR
                        IC = (IR[2] - '0') * 10 + (IR[3] - '0');
                        // If the IC is not toggled, set PI to 3
                        if (toggle[IC] == 0) {
                            PI = 3;
                            break;
                        }
                        // Get the address from the memory map
                        t = MAP(IC / 10 * 10) * 10 + IC % 10;
                        // If the IC is out of range, set PI to 2
                        if (IC < 0 || IC > 99) {
                            PI = 2;
                            break;
                        }
                        // Copy the memory to the register
                        for (int i = 0; i < 4; i++) {
                            R[i] = M[i][t];
                        }
                        break;
            
                    case 'S':
                        // If the second character is not 'R', set PI to 1
                        if (IR[1] != 'R') {
                            PI = 1;
                            break;
                        }
                        // Increment the instruction counter and total time counter
                        ICR++;
                        TTC += 2;
                        // Get the IC from the IR
                        IC = (IR[2] - '0') * 10 + (IR[3] - '0');
                        toggle[IC] = 1;
                        // If the IC is out of range, set PI to 2
                        if (IC < 0 || IC > 99) {
                            PI = 2;
                            break;
                        }
                        t = MAP(IC / 10 * 10) * 10 + IC % 10;
                        // Get the address from the memory map
                        for (int i = 0; i < 4; i++) {
                        // Copy the register to the memory
                            M[i][t] = R[i];
                        }
                        break;
            
                    case 'C':
                        if (IR[1] != 'R') {
                        // If the second character is not 'R', set PI to 1
                            PI = 1;
                            break;
                        }
                        ICR++;
                        // Increment the instruction counter and total time counter
                        TTC++;
                        IC = (IR[2] - '0') * 10 + (IR[3] - '0');
                        // Get the IC from the IR
                        if (toggle[IC] == 0) {
                        // If the IC is not toggled, set PI to 3
                            PI = 3;
                            break;
                        }
                        t = MAP(IC / 10 * 10) * 10 + IC % 10;
                        // Get the address from the memory map
                        if (IC < 0 || IC > 99) {
                        // If the IC is out of range, set PI to 2
                            PI = 2;
                            break;
                        }
                        for (int i = 0; i < 4; i++) {
                        // Compare the memory and register
                            if (M[i][t] != R[i]) {
                                c = 0;
                            }
                        }
                        break;
            
                    case 'B':
                        if (IR[1] != 'T') {
                        // If the second character is not 'T', set PI to 1
                            PI = 1;
                            break;
                        }
                        ICR++;
                        // Increment the instruction counter and total time counter
                        TTC++;
                        IC = (IR[2] - '0') * 10 + (IR[3] - '0');
                        // Get the IC from the IR
                        if (toggle[IC] == 0) {
                        // If the IC is not toggled, set PI to 3
                            PI = 3;
                            break;
                        }
                        if (IC < 0 || IC > 99) {
                        // If the IC is out of range, set PI to 2
                            PI = 2;
                            break;
                        }
                        break;
            
                    case 'H':
                        ICR++;
                        // Increment the instruction counter and total time counter
                        TTC++;
                        return;
                        // Return
                        break;
            
                    default:
                        PI = 1;
                        // Set PI to 1
                        break;
                }
            
                m++;
                // Increment the memory pointer
                if (v < 10) {
                // If the variable v is less than 10, increment it and execute the function again
                    v++;
                    EXECUTE();
                }
            }
            
            void READ_FILE() {
                // Open the input file
                input = fopen("input.txt", "r");
                // Read the file line by line
                while (fgets(line, sizeof(line), input) != NULL) {
                    // If PCI is 1, load the instruction into the buffer
                    if(PCI == 1){
                        x=0;
                        // Remove spaces from the line
                        for(int i=0; i<strlen(line); i++){
                            if(line[i] != ' '){
                                line2[x] = line[i];
                                x++;
                            }
                        }
            
                        // Load the instruction into the buffer
                        LOADINSTRUCTIONTOBUFFER(line2, strlen(line2)/40, strlen(line2)/40);
                        PCI=0;
                    }
            
                    // If DCI is 1, load the data into the buffer
                    if(DCI == 1){
                        // If the line starts with '$', execute the instruction
                        if(line[0] == '$'){
                            DCI = 0;
                            bp=0;
                            m=((M[2][PTR] - '0') * 10 + (M[3][PTR] - '0')) * 10;
                            v=0;
                            EXECUTE();
                        }else{
                            // Otherwise, load the data into the buffer
                            int j=0;
                            for(int i=0; i<strlen(line); i++){
                                if(j>3){
                                    j=0;
                                    bp++;
                                }
                                BUFF[j][bp] = line[i];
                                j++;
                            }
                            bp++;
                        }
                    }
            
                    // If the line starts with '$', process the instruction
                    if(line[0] == '$'){
                        switch(line[1]){
                            // If the instruction is 'A', initialize the job
                            case 'A':
                                INIT();
                                for(int i=0; i<4; i++){
                                    job[i] = line[5+i];
                                    ttl[i] = line[10+i];
                                    tll[i] = line[15+i];
                                }
                                for(int i=0; i<4; i++){
                                    TTL *= 10;
                                    TTL += ttl[i] - '0';
                                    TLL *= 10;
                                    TLL += tll[i] - '0';
                                }
                                PCI=1;
                                break;
            
                            // If the instruction is 'D', set DCI to 1
                            case 'D':
                                DCI=1;
                                bp=0;
                                break;
            
                            // If the instruction is not 'A' or 'D', reset PCI and DCI
                            default:
                                output = fopen("output.txt", "a");
                                fprintf(output, "\n\n");
                                fclose(output);
                                PCI=0;
                                DCI=0;
                        }
                    }
                }
            }
            
            void LOADINSTRUCTIONSETINTOMEMORY(){
                m=randAd[ptr] * 10;
                M[2][PTR+ptl] = (randAd[ptr]/10) + '0';
                M[3][PTR+ptl] = (randAd[ptr]%10) + '0';
                ptr++;
                ptl++;
                int y=0;
            
                while(BUFF[0][y] != '-' && y<10){
                    M[0][m] = BUFF[0][y];
                    if(BUFF[0][y] == 'P' && BUFF[1][y] == 'D')++LLC;
                    if(BUFF[0][y] != 'H'){
                        M[1][m] = BUFF[1][y];
                        M[2][m] = BUFF[2][y];
                        M[3][m] = BUFF[3][y];
                    }
                    y++;
                    m++;
                }
            
                for(int i=0; i<10; i++){
                    for(int j=0; j<4; j++){
                        BUFF[j][i] = '-';
                    }
                }
                m=0;
            }
            
            void CHECKERRORS(){
                if(TTC+1 > TTL){
                    errors = 1;
                    output = fopen("output.txt", "a");
                    fprintf(output, "Error:TIME LIMIT EXCEEDED \n");
                    fprintf(output, "IC:%d IR:%s TTC:%d TTL:%d LLC:%d\n TLL:%d", ICR, IR, TTC, TTL, LLC,TLL);
                    fclose(output);
                }
                if(LLC > TLL){
                    errors = 1;
                    output = fopen("output.txt", "a");
                    fprintf(output, "Error:LINE LIMIT EXCEEDED \n");
                    fprintf(output, "IC:%d IR:%s TTC:%d TTL:%d LLC:%d TLL:%d\n", ICR, IR, TTC, TTL, LLC,TLL);
                    fclose(output);
                }
                if(PI>0){
                    errors = 1;
                    if(PI==1){
                        output = fopen("output.txt", "a");
                        fprintf(output, "Error:OPCODE Error \n");
                        fprintf(output, "IC:%d IR:%s TTC:%d TTL:%d LLC:%d TLL:%d\n", ICR, IR, TTC, TTL, LLC,TLL);
                        fclose(output);
                    }
                    if(PI==2){
                        output = fopen("output.txt", "a");
                        fprintf(output, "Error:OPERAND Error\n");
                        fprintf(output, "IC:%d IR:%s TTC:%d TTL:%d LLC:%d\n", ICR, IR, TTC, TTL, LLC);
                        fclose(output);
                    }
                    if(PI==3){
                        output = fopen("output.txt", "a");
                        fprintf(output, "Error:INVALID PAGE FAULT \n");
                        fprintf(output, "IC:%d IR:%s TTC:%d TTL:%d LLC:%d\n", ICR, IR, TTC, TTL, LLC);
                        fclose(output);
                    }
                    if(PI==4){
                        output = fopen("output.txt", "a");
                        fprintf(output, "Error:OUT OF DATA \n");
                        fprintf(output, "IC:%d IR:%s TTC:%d TTL:%d LLC:%d\n", ICR, IR, TTC, TTL, LLC);
                        fclose(output);
                    }
                }
            }
            
            int main(){
                READ_FILE();
                PRINTMEMORY();
                fclose(input);
                return 0;
            }
            
            
            
            
            
            
































            </pre>
        <br>
        
        <h1>Socket programming(python)</h1>
        <h3>server.py</h3>
        <pre>
            import socket

# Define the server address and port
HOST = '127.0.0.1'  # Localhost
PORT = 8080          # Port to listen on

# Create a socket object
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Bind the socket to the address and port
server_socket.bind((HOST, PORT))

# Listen for incoming connections (max 1 connection)
server_socket.listen(1)
print("Server is waiting for a connection...")

# Accept a connection from the client
client_socket, client_address = server_socket.accept()
print(f"Connection established with {client_address}")

# Send a "Hello" message to the client
message = "Hello, Client!"
client_socket.sendall(message.encode())  # Send encoded message

print(f"Sent message to client: {message}")

# Close the connection
client_socket.close()
server_socket.close()
            
        </pre>
        <br>
        <h3>client.py</h3>
        <pre>
            import socket

# Define the server address and port
HOST = '127.0.0.1'  # Localhost
PORT = 8080          # Port to connect to

# Create a socket object
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Connect to the server
client_socket.connect((HOST, PORT))

# Receive the message from the server
message = client_socket.recv(1024).decode()  # Receive and decode the message
print(f"Received from server: {message}")

# Close the socket
client_socket.close()

        </pre>


        <br>



        <h1>Socket programming(c language)</h1>
        <h3>server</h3>
        <pre>
                #include +stdio.h+
                #include +string.h+
                #include +stdlib.h+
                #include +unistd.h+
                #include +arpa/inet.h+
                                   
                #define PORT 5000
                
                int main() {
                    int server_fd, new_socket;
                    struct sockaddr_in address;
                    int addrlen = sizeof(address);
                    char *hello = "Hello";
                
                    // Create socket file descriptor
                    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
                        perror("socket failed");
                        exit(EXIT_FAILURE);
                    }
                
                    // Define server address
                    address.sin_family = AF_INET;
                    address.sin_addr.s_addr = INADDR_ANY;
                    address.sin_port = htons(PORT);
                
                    // Bind the socket to the address
                    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
                        perror("bind failed");
                        close(server_fd);
                        exit(EXIT_FAILURE);
                    }
                
                    // Listen for incoming connections
                    if (listen(server_fd, 3) < 0) {
                        perror("listen failed");
                        close(server_fd);
                        exit(EXIT_FAILURE);
                    }
                
                    printf("Server is listening on port %d\n", PORT);
                
                    // Accept a connection
                    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) < 0) {
                        perror("accept failed");
                        close(server_fd);
                        exit(EXIT_FAILURE);
                    }
                
                    // Send a "Hello" message to the client
                    send(new_socket, hello, strlen(hello), 0);
                    printf("Hello message sent\n");
                
                    // Close the socket
                    close(new_socket);
                    close(server_fd);
                    return 0;
                }
            
        </pre>
        <br>
        <h3>client</h3>
        <pre>
            #include +stdio.h+
                #include +string.h+
                #include +stdlib.h+
                #include +unistd.h+
                #include +arpa/inet.h+
                
                #define PORT 5000
                
                int main() {
                    int sock = 0;
                    struct sockaddr_in serv_addr;
                    char buffer[1024] = {0};
                
                    // Create socket file descriptor
                    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
                        printf("\n Socket creation error \n");
                        return -1;
                    }
                
                    // Define server address
                    serv_addr.sin_family = AF_INET;
                    serv_addr.sin_port = htons(PORT);
                
                    // Convert IPv4 and IPv6 addresses from text to binary form
                    if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0) {
                        printf("\nInvalid address/ Address not supported \n");
                        return -1;
                    }
                
                    // Connect to the server
                    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
                        printf("\nConnection Failed \n");
                        return -1;
                    }
                
                    // Read the message from the server
                    read(sock, buffer, 1024);
                    printf("Message from server: %s\n", buffer);
                
                    // Close the socket
                    close(sock);
                    return 0;
                }
        </pre>
    </div>


    <br>
    <h1>Go back N</h1>
    <pre>
        #include +stdio.h+
            #include +stdlib.h+
            
            void simulate_go_back_n(int total_frames, int window_size, int lost_frame) {
                int sent_frame = 0;  // Current frame being sent
                int ack_frame = 0;   // Last acknowledged frame
                int retransmit_start = 0; // Frame from where to start retransmission
            
                while (ack_frame < total_frames) {
                    printf("\nSender is sending frames...\n");
            
                    // Sender sends frames within the window size limit
                    for (int i = 0; i < window_size && sent_frame < total_frames; i++) {
                        if (sent_frame == lost_frame) {
                            printf("Frame %d is lost! Go-Back-N ARQ triggered!\n", sent_frame);
                            retransmit_start = lost_frame; // Set retransmission start point
                            break; // Stop sending further frames after losing the frame
                        }
                        printf("Frame %d sent.\n", sent_frame);
                        sent_frame++;
                    }
            
                    printf("\nReceiver is receiving and acknowledging frames...\n");
            
                    // Receiver processes received frames and acknowledges
                    for (int i = ack_frame; i < sent_frame; i++) {
                        if (i == lost_frame) {
                            printf("Receiver did not receive Frame %d. Discarding subsequent frames. Waiting for retransmission.\n", i);
                            sent_frame = retransmit_start; // Go back to the lost frame
                            break; // Exit loop to allow retransmission from the lost frame
                        } else {
                            printf("ACK for Frame %d received.\n", i);
                            ack_frame++;
                        }
                    }
            
                    // After retransmission of the lost frame, the receiver continues normally
                    if (ack_frame == lost_frame) {
                        lost_frame = -1; // Lost frame has been retransmitted and acknowledged
                    }
                }
            
                printf("\nAll frames successfully transmitted and acknowledged.\n");
            }
            
            int main() {
                int m, total_frames, window_size, lost_frame;
            
                printf("Go-Back-N Sliding Window Protocol Simulation\n");
            
                // Input the value of m first
                printf("\nEnter the value of m (for sequence numbers 2^m): ");
                scanf("%d", &m);
            
                // Window size calculation (2^m - 1)
                window_size = (1 << m) - 1; // Window size = 2^m - 1
            
                // Input the total number of frames
                printf("Enter total number of frames: ");
                scanf("%d", &total_frames);
            
                // Input the frame to be lost
                printf("Enter the frame number to be lost: ");
                scanf("%d", &lost_frame);
            
                if (lost_frame >= total_frames) {
                    printf("Frame number to be lost exceeds total frames.\n");
                    return 1;
                }
            
                printf("Window size: %d\n", window_size);
                printf("Frame %d is set to be lost.\n", lost_frame);
            
                // Simulate Go-Back-N
                simulate_go_back_n(total_frames, window_size, lost_frame);
            
                return 0;
            }
    </pre>

    <br>
    <h1>Selective</h1>
    <pre>
        #include +stdio.h+
            #include +stdlib.h+
            
            int main() {
                int total_frames;  // Total number of frames to be sent
                int *frames;       // Dynamic array to hold the frames
                int *ack;          // Dynamic array to hold the acknowledgment status for each frame
                int lost_frame;    // To store the frame number chosen to be lost
            
                // Ask the user for the number of frames
                printf("Enter the total number of frames to be sent: ");
                scanf("%d", &total_frames);
            
                // Allocate memory dynamically for frames and acknowledgment arrays
                frames = (int *)malloc(total_frames * sizeof(int));
                ack = (int *)malloc(total_frames * sizeof(int));
            
                // Check if memory allocation is successful
                if (frames == NULL || ack == NULL) {
                    printf("Memory allocation failed. Exiting program.\n");
                    return 1;
                }
            
                // Initialize frames and acknowledgment arrays
                for (int i = 0; i < total_frames; i++) {
                    frames[i] = i + 1;  // Frame numbers start from 1
                    ack[i] = 0;         // Initially, no frames are acknowledged
                }
            
                // Ask the user which frame should be "lost"
                printf("Enter the frame number to be lost (1 to %d): ", total_frames);
                scanf("%d", &lost_frame);
            
                // Validate user input
                if (lost_frame < 1 || lost_frame > total_frames) {
                    printf("Invalid frame number. Exiting program.\n");
                    free(frames);
                    free(ack);
                    return 1;
                }
            
                lost_frame -= 1; //
                printf("Sending frames...\n");
            
                // Simulate sending frames and receiving acknowledgments
                for (int i = 0; i < total_frames; i++) {
                    if (i == lost_frame) {
                        printf("Frame %d lost.\n", frames[i]);
                    } else {
                        printf("Frame %d sent and acknowledged.\n", frames[i]);
                        ack[i] = 1;  // Mark frame as acknowledged
                    }
                }
            
                // Check for lost frames and resend them
                printf("Resending lost frames...\n");
                for (int i = 0; i < total_frames; i++) {
                    if (ack[i] == 0) {
                        printf("Resending frame %d.\n", frames[i]);
                        ack[i] = 1;  // After resending, mark frame as acknowledged
                    }
                }
            
                // Final status
                printf("All frames have been successfully sent and acknowledged.\n");
            
                // Free the dynamically allocated memory
                free(frames);
                free(ack);
            
                return 0;
            }
    </pre>

    <br>
    <h1>Classification</h1>
    <pre>
        #include +stdio.h+
            #include +string.h+
            #include +stdlib.h+
            
            int find_ip_class(int first_octet) {
                if (first_octet >= 1 && first_octet <= 126) {
                    return 'A';  // Class A
                } else if (first_octet >= 128 && first_octet <= 191) {
                    return 'B';  // Class B
                } else if (first_octet >= 192 && first_octet <= 223) {
                    return 'C';  // Class C
                } else if (first_octet >= 224 && first_octet <= 239) {
                    return 'D';  // Class D (Multicast)
                } else if (first_octet >= 240 && first_octet <= 255) {
                    return 'E';  // Class E (Reserved)
                } else {
                    return 'U';  // Unknown
                }
            }
            
            char* find_ip_type(int first_octet, int second_octet) {
                // Check for private IP ranges
                if (first_octet == 10) {
                    return "Private";  // Class A private
                } else if (first_octet == 172 && (second_octet >= 16 && second_octet <= 31)) {
                    return "Private";  // Class B private
                } else if (first_octet == 192 && second_octet == 168) {
                    return "Private";  // Class C private
                } else {
                    return "Public";
                }
            }
            
            int main() {
                char ip_address[20];
                int octets[4];
            
                // Input the IP address
                printf("Enter an IP address (e.g., 192.168.1.1): ");
                scanf("%s", ip_address);
            
                // Parse the IP address 0into four octets
                sscanf(ip_address, "%d.%d.%d.%d", &octets[0], &octets[1], &octets[2], &octets[3]);
            
                // Find the class
                char ip_class = find_ip_class(octets[0]);
            
                // Find if it's private or public
                char *ip_type = find_ip_type(octets[0], octets[1]);
            
                // Output the results
                printf("IP Address: %s\n", ip_address);
                printf("Class: %c\n", ip_class);
                printf("Type: %s\n", ip_type);
            
                return 0;
            }
    </pre>

    <br>
    <h1>Djikstra</h1>
    <pre>
        #include +stdio.h+
            #include +limits.h+
            #define V 5 // Number of vertices in the graph
            
            // Find the vertex with the minimum distance value
            int minDistance(int dist[], int sptSet[]) {
                int min = INT_MAX, min_index;
            
                for (int v = 0; v < V; v++)
                    if (sptSet[v] == 0 && dist[v] <= min)
                        min = dist[v], min_index = v;
            
                return min_index;
            }
            
            // Function to print the shortest path
            void printPath(int parent[], int j) {
                // Base case: If j is the source node
                if (parent[j] == -1)
                    return;
            
                printPath(parent, parent[j]);
                printf(" -> %d", j);
            }
            
            // Dijkstra's algorithm to find the shortest path
            void dijkstra(int graph[V][V], int src, int dest) {
                int dist[V];     
                int sptSet[V];  
                int parent[V];   
                
                for (int i = 0; i < V; i++) {
                    dist[i] = INT_MAX;
                    sptSet[i] = 0;
                    parent[i] = -1;
                }
            
                dist[src] = 0; // Distance of source vertex from itself is always 0
            
                for (int count = 0; count < V - 1; count++) {
                    int u = minDistance(dist, sptSet); // Pick the minimum distance vertex
                    sptSet[u] = 1; // Mark the picked vertex as processed
            
                    for (int v = 0; v < V; v++) {
                        if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX 
                            && dist[u] + graph[u][v] < dist[v]) {
                            dist[v] = dist[u] + graph[u][v];
                            parent[v] = u; // Set parent for path tracing
                        }
                    }
                }
            
                // Print the shortest distance and path
                printf("Shortest path from node %d to %d is %d\n", src, dest, dist[dest]);
                printf("Path: %d", src);
                printPath(parent, dest);
                printf("\n");
            }
            
            int main() {
                int graph[V][V] = {{0, 10, 20, 0, 0},
                                   {10, 0, 5, 16, 0},
                                   {20, 5, 0, 2, 30},
                                   {0, 16, 2, 0, 8},
                                   {0, 0, 30, 8, 0}};
                
                int src, dest;
                
                // Take user input for source and destination nodes
                printf("Enter source node (0-%d): ", V-1);
                scanf("%d", &src);
                
                printf("Enter destination node (0-%d): ", V-1);
                scanf("%d", &dest);
                
                if (src >= 0 && src < V && dest >= 0 && dest < V) {
                    dijkstra(graph, src, dest);
                } else {
                    printf("Invalid input. Please enter nodes between 0 and %d.\n", V-1);
                }
            
                return 0;
            }
    </pre>

    <br>
    <h1>Djikstra(another method)</h1>
    <pre>
        #include +stdio.h+
            #include +stdbool.h+
            #include +limits.h+
            
            int no_vertices;
            
            void printGraph(int adj[][no_vertices]) {
                for (int i = 0; i < no_vertices; i++) {
                    for (int j = 0; j < no_vertices; j++) {
                        printf("%d ", adj[i][j]);
                    }
                    printf("\n");
                }
            }
            
            void insertPriorityQueue(int queue[], int distance[], int *size, int vertex) {
                queue[(*size)++] = vertex;
            
                for (int i = *size - 1; i > 0; i--) {
                    if (distance[queue[i]] > distance[queue[i - 1]]) {
                        // Swap
                        int temp = queue[i];
                        queue[i] = queue[i - 1];
                        queue[i - 1] = temp;
                    } else {
                        break;
                    }
                }
            }
            
            int extractMin(int queue[], int *size) {
                if (*size == 0) return -1; // Queue is empty
                return queue[--(*size)]; // Remove and return the minimum element
            }
            
            int main() {
                int s, d, dist;
            
                printf("\nEnter the number of vertices: ");
                scanf("%d", &no_vertices);
                int adj[no_vertices][no_vertices];
            
                for (int i = 0; i < no_vertices; i++) {
                    for (int j = 0; j < no_vertices; j++) {
                        adj[i][j] = 0;
                    }
                }
            
                while (true) {
                    printf("Enter an edge from node (0 to %d) to node (0 to %d) and its distance (-1 -1 to stop): ", no_vertices - 1, no_vertices - 1);
                    scanf("%d %d %d", &s, &d, &dist);
                    if (s == -1 && d == -1) {
                        break;
                    }
                    adj[s][d] = dist;
                    adj[d][s] = dist;
                }
            
                printGraph(adj);
            
                int z;
                int distance[no_vertices];
                int visited[no_vertices];
                int queue[no_vertices];
                int size = 0; // Size of the priority queue
            
                for (int i = 0; i < no_vertices; i++) {
                    visited[i] = 0;
                    distance[i] = INT_MAX; // Initialize distances to infinity
                }
            
                printf("\nEnter the source node: ");
                scanf("%d", &z);
                distance[z] = 0;
                insertPriorityQueue(queue, distance, &size, z); // Insert source node into the queue
            
                calculation(adj, queue, visited, distance, &size);
            
                printf("\nThe value in the distance list:");
                for (int i = 0; i < no_vertices; i++) {
                    printf("\nThe distance of the %d th node from the source is: %d", i, distance[i]);
                }
            
                return 0;
            }
            
            void calculation(int adj[][no_vertices], int queue[], int visited[], int distance[], int *size) {
                while (*size > 0) {
                    int z = extractMin(queue, size); // Get the node with the minimum distance
                    visited[z] = 1;
            
                    for (int i = 0; i < no_vertices; i++) {
                        if (adj[z][i] != 0 && visited[i] != 1) {
                            if (distance[z] + adj[z][i] < distance[i]) {
                                distance[i] = distance[z] + adj[z][i];
                                insertPriorityQueue(queue, distance, size, i); // Insert updated distance node
                            }
                        }
                    }
                    printf("%d ", z); // Print the visited node
                }
            }
            
    </pre>

    <h1>CRC0</h1>
    <pre>
        #include +stdio.h+
            #include +math.h+
            
            void main()
            {
                int divident[10];
                printf("Enter the block code:\n");
                for(int i=0;i<7;i++)
                {
                    scanf("%d",&divident[i]);
                }
            
                int length = 0;
                int divisor[4];
                printf("\nEnter the divisor:\n");
                for(int i=0;i<4;i++)
                {
                    scanf("%d",&divisor[i]);
                }
            
                for(int i=7;i<7+3;i++)
                {
                    divident[i] = 0;
                }
            
                int divlen = 3;
                int a[4],x[4];
                for(int i=0;i<4;i++)
                {
                    a[i] = divident[i];
                }
            
                for(int i=4;i<10;i++)
                {
                    if(a[0] == 1)
                    {
                        for(int i=0;i<4;i++)
                        {
                            if(a[i] == divisor[i])
                            {
                                x[i] = 0;
                            }
                            else
                            {
                                x[i] = 1;
                            }
                        }
            
                        for(int i=0;i<4;i++)
                        {
                            a[i] = x[i];
                        }
                    }
                    else if(a[0] == 0){}
            
                    else{
                        printf("kay teri chuklay bhava");
                    }
            
                    for(int i=0;i<3;i++)
                    {
                        a[i] = a[i+1];
                    }
                    a[3] = divident[i];
                }
            
                if(a[0] == 1)
                {
                    for(int i=0;i<4;i++)
                    {
                        if(a[i] == divisor[i])
                        {
                            x[i] = 0;
                        }
                        else
                        {
                            x[i] = 1;
                        }
                    }
            
                    for(int i=0;i<4;i++)
                    {
                        a[i] = x[i];
                    }
                }
                else if(a[0] == 0){}
            
                printf("\nCRC of given condition is:\n");
                for(int i=1;i<4;i++)
                {
                    printf("%d",a[i]);
                }
            }
            
            
    </pre>

    <h1>crc</h1>
    <pre>
        #include <stdio.h>
            #include <string.h>
            
            #define MAX 100
            
            // Function to perform XOR operation
            void xorOperation(char dividend[], char divisor[], int n) {
                for (int i = 0; i < n; i++) {
                    dividend[i] = (dividend[i] == divisor[i]) ? '0' : '1';
                }
            }
            
            // Function to perform CRC Division
            void crcDivision(char data[], char divisor[], char crc[]) {
                int dataLen = strlen(data);
                int divisorLen = strlen(divisor);
            
                char temp[MAX];
                strcpy(temp, data);
            
                for (int i = 0; i <= dataLen - divisorLen; i++) {
                    if (temp[i] == '1') {
                        xorOperation(temp + i, divisor, divisorLen);
                    }
                }
            
                strcpy(crc, temp + dataLen - divisorLen + 1);
            }
            
            // Function to check for errors
            int checkForErrors(char crc[]) {
                for (int i = 0; i < strlen(crc); i++) {
                    if (crc[i] == '1') {
                        return 1;  // Error found
                    }
                }
                return 0;  // No error
            }
            
            // Function to flip a bit in a string at a given position
            void flipBit(char data[], int pos) {
                data[pos] = (data[pos] == '1') ? '0' : '1';
            }
            
            int main() {
                char data[MAX], divisor[MAX], crc[MAX];
                int corrected = 0;
            
                printf("Enter the original data: ");
                scanf("%s", data);
            
                printf("Enter the divisor: ");
                scanf("%s", divisor);
            
                int dataLen = strlen(data);
                int divisorLen = strlen(divisor);
            
                // Append zeros to the data
                for (int i = 0; i < divisorLen - 1; i++) {
                    data[dataLen + i] = '0';
                }
                data[dataLen + divisorLen - 1] = '\0';
            
                // Perform CRC division
                crcDivision(data, divisor, crc);
            
                printf("CRC: %s\n", crc);
            
                // Simulate receiving data with CRC
                printf("Enter the received data (with CRC): ");
                scanf("%s", data);
            
                crcDivision(data, divisor, crc);
            
                if (checkForErrors(crc)) {
                    printf("Error detected. Attempting to correct...\n");
            
                    for (int i = 0; i < dataLen + divisorLen - 1; i++) {
                        flipBit(data, i);
                        crcDivision(data, divisor, crc);
            
                        if (!checkForErrors(crc)) {
                            printf("Error corrected! Corrected data: %s\n", data);
                            corrected = 1;
                            break;
                        }
            
                        // Flip the bit back if not corrected
                        flipBit(data, i);
                    }
            
                    if (!corrected) {
                        printf("Unable to correct the error.\n");
                    }
                } else {
                    printf("No error detected in the received data.\n");
                }
            
                return 0;
            }
    </pre>

    <template id="template-news-card">
        <div class="card">
            <div class="card-header">
                <img src="https://via.placeholder.com/400x200" alt="news-image" id="news-img">
            </div>
            <div class="card-content">
                <h3 id="news-title">This is the Title</h3>
                <h6 class="news-source" id="news-source">End Gadget 26/08/2023</h6>
                <p class="news-desc" id="news-desc">Lorem, ipsum dolor sit amet consectetur adipisicing elit. Recusandae saepe quis voluptatum quisquam vitae doloremque facilis molestias quae ratione cumque!</p>
            </div>
        </div>
    </template>

    <script src="script.js"></script>
</body>
</html> 
